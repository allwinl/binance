# bot_DIAGNOSTIC.py - REAL PRODUCTION ENVIRONMENT
# Tests: position reading, open long/short, close long/short, hedge mode support
# VERY SMALL sizes only! REAL MONEY – STOP AFTER 1-2 CYCLES!

import time
import logging
from datetime import datetime, timezone
import traceback

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError as e:
    print(f"Import error: {e}")
    print("pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

# ─── CONFIG ─────────────────────────────────────────────────────────────────
USE_TESTNET     = False                 # Real production – REAL MONEY
SYMBOL          = "XRPUSDT"
TEST_QUANTITY   = 10                    # Very small for XRP perpetual (~few cents to dollars)
LEVERAGE        = 5                     # Low for safety
HEDGE_MODE      = True                  # Set True to test Hedge mode (LONG/SHORT sides)
                                        # Set False to test One-way mode (automatic reversal)
SLEEP_SECONDS   = 60                    # Time between cycles

API_KEY = 'swNCkZLoqzFnYPreUDrFAAnoAxsx16PcJSDlU3AEpep7MwaOCVXzq3YHUDJkZvu8'
API_SECRET = 'f7774SEvatAbZJHNP6NYZu6dtAb6zxYUBmxQp6c8d90PbNvlvKLYl1ofF7A1J4qn'

BASE_PATH = DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL  # production

# ─── Logging ────────────────────────────────────────────────────────────────
logging.basicConfig(
    filename='diagnostic_real_xrp.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

# ─── Client Initialization ──────────────────────────────────────────────────
print(">>> WARNING: REAL PRODUCTION ENVIRONMENT – REAL MONEY AT RISK <<<")
print("Initializing client...")

configuration = ConfigurationRestAPI(
    api_key=API_KEY,
    api_secret=API_SECRET,
    base_path=BASE_PATH
)

client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

print(f"Client ready | Production mode | Hedge target: {HEDGE_MODE}")
logger.critical(f"DIAGNOSTIC START – REAL MONEY – {SYMBOL} – QTY={TEST_QUANTITY}")

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol):
    try:
        positions = client.rest_api.position_risk(symbol=symbol)
        print("Raw position_risk response:", positions)
        if not positions:
            return 0.0, 0.0

        long_qty = 0.0
        short_qty = 0.0

        for pos in positions:
            side = pos.get('positionSide', 'BOTH')
            amt = float(pos.get('positionAmt', 0))
            if side == 'LONG' or (side == 'BOTH' and amt > 0):
                long_qty = amt
            elif side == 'SHORT' or (side == 'BOTH' and amt < 0):
                short_qty = amt

        return long_qty, short_qty
    except Exception as e:
        print(f"position_risk FAILED: {e}")
        logger.error(f"position query failed: {e}\n{traceback.format_exc()}")
        return 0.0, 0.0


def market_order(symbol, side: str, quantity: float, position_side: str = None):
    try:
        params = {
            "symbol": symbol,
            "side": side.upper(),
            "type": "MARKET",
            "quantity": quantity
        }
        if HEDGE_MODE and position_side:
            params["positionSide"] = position_side.upper()

        print("Sending order params:", params)
        order = client.rest_api.new_order(**params)
        msg = f"ORDER FILLED → {side.upper()} {quantity} {symbol}"
        if position_side:
            msg += f" ({position_side})"
        msg += f"  ID: {order.get('orderId', 'N/A')}"
        print(msg)
        logger.info(msg)
        return order
    except Exception as e:
        print(f"market_order FAILED: {e}")
        logger.error(f"order failed: {e}\n{traceback.format_exc()}")
        return None


def close_side(symbol, side: str, qty: float):
    if abs(qty) < 0.0001:
        print(f"No {side} position to close")
        return None
    order_side = "SELL" if side == "LONG" else "BUY"
    qty_abs = abs(qty)
    print(f"Closing {side} → {order_side} {qty_abs}")
    return market_order(symbol, order_side, qty_abs, position_side=side if HEDGE_MODE else None)


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_leverage(symbol=symbol, leverage=lev)
        print(f"Leverage set to {lev}x")
        logger.info(f"Leverage set {lev}x")
    except Exception as e:
        print(f"set_leverage FAILED: {e}")
        if "2024" not in str(e):  # ignore already set error
            logger.warning(f"leverage: {e}")


def set_hedge_mode(enable_hedge: bool = True):
    """Try to set hedge mode via /fapi/v1/positionSide/dual"""
    try:
        dual = "true" if enable_hedge else "false"
        resp = client.rest_api.change_position_mode(dualSidePosition=dual)
        print(f"Position mode set attempt: {'Hedge' if enable_hedge else 'One-way'} → {resp}")
        logger.info(f"Set position mode to {'Hedge' if enable_hedge else 'One-way'} → {resp}")
    except Exception as e:
        print(f"set_hedge_mode FAILED: {e}")
        logger.warning(f"Could not set hedge mode: {e} (might already be set or open positions exist)")


# ─── Diagnostic cycle ───────────────────────────────────────────────────────
STATE = "SHOW_STATUS"
cycle_count = 0

if __name__ == "__main__":
    print(f"Starting DIAGNOSTIC – REAL MONEY – {SYMBOL}")
    logger.critical(f"REAL MONEY DIAGNOSTIC START – {SYMBOL} – SMALL TEST")

    set_leverage(SYMBOL, LEVERAGE)

    # Optional: try to set hedge mode (only succeeds if no open positions/orders)
    # Comment out after first run if you already have the desired mode
    set_hedge_mode(enable_hedge=HEDGE_MODE)

    while True:
        cycle_count += 1
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        print(f"\n=== Cycle {cycle_count} – {now} ===")

        long_qty, short_qty = get_position(SYMBOL)
        print(f"Position → LONG: {long_qty:.4f} | SHORT: {short_qty:.4f}")

        if STATE == "SHOW_STATUS":
            print("→ Showing status only...")
            STATE = "OPEN_LONG"

        elif STATE == "OPEN_LONG":
            if long_qty == 0 and short_qty == 0:
                print("→ Opening small LONG")
                market_order(SYMBOL, "BUY", TEST_QUANTITY, "LONG" if HEDGE_MODE else None)
            else:
                print("→ Already in position – skipping open long")
            STATE = "CLOSE_LONG"

        elif STATE == "CLOSE_LONG":
            if long_qty > 0.0001:
                print("→ Closing LONG")
                close_side(SYMBOL, "LONG", long_qty)
            else:
                print("→ No LONG to close")
            STATE = "OPEN_SHORT"

        elif STATE == "OPEN_SHORT":
            if long_qty == 0 and short_qty == 0:
                print("→ Opening small SHORT")
                market_order(SYMBOL, "SELL", TEST_QUANTITY, "SHORT" if HEDGE_MODE else None)
            else:
                print("→ Already in position – skipping open short")
            STATE = "CLOSE_SHORT"

        elif STATE == "CLOSE_SHORT":
            if short_qty < -0.0001:
                print("→ Closing SHORT")
                close_side(SYMBOL, "SHORT", short_qty)
            else:
                print("→ No SHORT to close")
            STATE = "SHOW_STATUS"  # back to start

        print("─" * 50)
        time.sleep(SLEEP_SECONDS)
