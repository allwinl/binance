# bot.py
# Binance USDS-M Futures bot – REAL MAINNET – single file

import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
import math
import sys

# ─── Fix: import Optional ────────────────────────────────────────────────
from typing import Dict, Any, Optional

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    sys.exit(1)

binance_cfg = config.get("binance", {})
trading_cfg = config.get("trading", {})

API_KEY     = binance_cfg.get("api_key")
API_SECRET  = binance_cfg.get("api_secret")

SYMBOL           = trading_cfg.get("symbol", "BTCUSDT")
LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QUANTITY = trading_cfg.get("default_quantity", 20.0)  # reasonable for XRPUSDT

if not API_KEY or not API_SECRET:
    print("ERROR: api_key/api_secret missing")
    sys.exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

symbol_precision = {"quantity": 3, "price": 2}
symbol_filters   = {}

def signed_request(method: str, endpoint: str, params: Optional[dict] = None, max_retries: int = 3) -> dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    query = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), query.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{query}&signature={sig}"

    for attempt in range(1, max_retries + 1):
        try:
            if method.upper() == "GET":
                r = requests.get(url, headers=HEADERS, timeout=10)
            elif method.upper() == "POST":
                r = requests.post(url, headers=HEADERS, timeout=10)
            else:
                raise ValueError("Unsupported method")

            r.raise_for_status()
            data = r.json()

            for h in r.headers:
                if "X-MBX-USED-WEIGHT" in h or "X-MBX-ORDER-COUNT" in h:
                    print(f"   {h}: {r.headers[h]}")

            if isinstance(data, dict) and "code" in data and data["code"] < 0:
                print(f"API ERROR: {data['code']} - {data.get('msg', 'no msg')}")
                if data["code"] in (-1001, -1003, -1008):
                    time.sleep(attempt * 2)
                    continue
            return data
        except Exception as e:
            print(f"Request failed (attempt {attempt}): {e}")
            time.sleep(attempt * 2)
    return {"error": "max retries exceeded"}

def load_symbol_info():
    global symbol_precision, symbol_filters
    try:
        ex = requests.get(f"{BASE_URL}/fapi/v1/exchangeInfo", timeout=8).json()
        for s in ex.get("symbols", []):
            if s["symbol"] == SYMBOL:
                for f in s.get("filters", []):
                    ft = f["filterType"]
                    if ft == "LOT_SIZE":
                        step = float(f["stepSize"])
                        symbol_precision["quantity"] = -int(round(math.log10(step)))
                        symbol_filters["stepSize"] = step
                        symbol_filters["minQty"]   = float(f["minQty"])
                    if ft == "PRICE_FILTER":
                        tick = float(f["tickSize"])
                        symbol_precision["price"] = -int(round(math.log10(tick)))
                    if ft == "MIN_NOTIONAL":
                        symbol_filters["minNotional"] = float(f.get("minNotional", 0))
                print(f"Loaded {SYMBOL}: qty prec={symbol_precision['quantity']}, price prec={symbol_precision['price']}")
                print(f"  minQty={symbol_filters.get('minQty')}, stepSize={symbol_filters.get('stepSize')}")
                if "minNotional" in symbol_filters:
                    print(f"  minNotional ≈ {symbol_filters['minNotional']} USDT")
                return
        print("Symbol not found in exchangeInfo → using defaults")
    except Exception as e:
        print(f"exchangeInfo failed: {e}")

def format_qty(qty: float) -> str:
    p = symbol_precision["quantity"]
    s = f"{qty:.{p}f}"
    return s.rstrip("0").rstrip(".") if "." in s else s

def confirm_action(msg: str) -> bool:
    ans = input(f"{msg}\nReally execute? [y/N] ").strip().lower()
    return ans in ("y", "yes", "y ")

def market_order(side: str, qty: Optional[float] = None, reduce_only: bool = False) -> dict:
    qty = qty or DEFAULT_QUANTITY
    qty_str = format_qty(qty)

    prompt = f"Sending MARKET {side.upper()} {qty_str} {SYMBOL} (reduceOnly={reduce_only})"
    if not confirm_action(prompt):
        print("Order cancelled by user.")
        return {"cancelled": True}

    params = {
        "symbol": SYMBOL,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qty_str,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    print(f"→ Sending order...")
    return signed_request("POST", "/fapi/v1/order", params)

def get_usdt_balance() -> float:
    data = signed_request("GET", "/fapi/v2/account")
    if "assets" in data:
        for asset in data["assets"]:
            if asset["asset"] == "USDT":
                return float(asset.get("availableForWithdrawal", 0))
    return 0.0

def get_position(symbol: str) -> dict:
    positions = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(positions, list) and positions:
        pos = positions[0]
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) > 1e-8:
            return pos
    return {}

def get_position_mode() -> str:
    data = signed_request("GET", "/fapi/v1/positionSide/dual")
    return "HEDGE" if data.get("dualSidePosition", False) else "ONE_WAY"

def setup_symbol():
    print("\nSetting leverage...")
    print(signed_request("POST", "/fapi/v1/leverage", {"symbol": SYMBOL, "leverage": LEVERAGE}))
    print("\nSetting margin type...")
    print(signed_request("POST", "/fapi/v1/marginType", {"symbol": SYMBOL, "marginType": MARGIN_TYPE}))

def long_cycle(qty: Optional[float] = None):
    if get_position_mode() == "HEDGE":
        print("Hedge mode detected — cycle assumes One-way mode")
        return
    qty = qty or DEFAULT_QUANTITY
    print("=== LONG cycle ===")
    open_res = market_order("BUY", qty, False)
    print(open_res)
    if "orderId" not in open_res:
        return
    time.sleep(3)
    pos = get_position(SYMBOL)
    if pos and float(pos["positionAmt"]) > 0:
        close_qty = abs(float(pos["positionAmt"]))
        print(f"Closing LONG with {close_qty}")
        close_res = market_order("SELL", close_qty, True)
        print(close_res)
    else:
        print("No LONG position detected after open")

def short_cycle(qty: Optional[float] = None):
    if get_position_mode() == "HEDGE":
        print("Hedge mode detected — cycle assumes One-way mode")
        return
    qty = qty or DEFAULT_QUANTITY
    print("=== SHORT cycle ===")
    open_res = market_order("SELL", qty, False)
    print(open_res)
    if "orderId" not in open_res:
        return
    time.sleep(3)
    pos = get_position(SYMBOL)
    if pos and float(pos["positionAmt"]) < 0:
        close_qty = abs(float(pos["positionAmt"]))
        print(f"Closing SHORT with {close_qty}")
        close_res = market_order("BUY", close_qty, True)
        print(close_res)
    else:
        print("No SHORT position detected after open")

def print_help():
    print(f"""
Loaded {SYMBOL}: qty prec={symbol_precision['quantity']}, price prec={symbol_precision['price']}
minQty={symbol_filters.get('minQty')}, stepSize={symbol_filters.get('stepSize')}

Commands:

  python bot.py balance           → available USDT
  python bot.py positions         → current positions
  python bot.py setup             → set leverage + margin type
  python bot.py buy  [qty]        → MARKET LONG (open)
  python bot.py sell [qty]        → MARKET SHORT (open)
  python bot.py long_cycle  [qty] → open LONG → close LONG
  python bot.py short_cycle [qty] → open SHORT → close SHORT
  python bot.py time              → server time
  python bot.py precision         → qty & price precision
  python bot.py mode              → position mode (One-way / Hedge)

No arguments → this help
""")

if __name__ == "__main__":
    load_symbol_info()

    args = sys.argv[1:]
    if not args:
        print_help()
        sys.exit(0)

    cmd = args[0].lower()
    qty_arg = float(args[1]) if len(args) > 1 else None

    if cmd == "balance":
        print(f"Available USDT: {get_usdt_balance():.2f}")

    elif cmd == "positions":
        positions = signed_request("GET", "/fapi/v2/positionRisk")
        active = [p for p in positions if abs(float(p.get("positionAmt", "0"))) > 1e-8]
        if not active:
            print("No open positions.")
        else:
            for p in active:
                amt = float(p["positionAmt"])
                side = "LONG" if amt > 0 else "SHORT"
                print(f"{p['symbol']} | {side} | amt: {amt:.{symbol_precision['quantity']}f} | PnL: {float(p['unRealizedProfit']):+.2f}")

    elif cmd == "setup":
        setup_symbol()

    elif cmd == "buy":
        print(market_order("BUY", qty_arg, False))

    elif cmd == "sell":
        print(market_order("SELL", qty_arg, False))

    elif cmd == "long_cycle":
        long_cycle(qty_arg)

    elif cmd == "short_cycle":
        short_cycle(qty_arg)

    elif cmd == "time":
        data = requests.get(f"{BASE_URL}/fapi/v1/time").json()
        ts = data.get("serverTime", 0)
        print(f"Server time: {ts} ms → {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime(ts / 1000))}")

    elif cmd == "precision":
        print(f"Qty precision: {symbol_precision['quantity']} decimals")
        print(f"Price precision: {symbol_precision['price']} decimals")

    elif cmd == "mode":
        mode = get_position_mode()
        print(f"Position mode: {mode}")

    else:
        print(f"Unknown command: {cmd}")
        print_help()
