import ccxt
import pandas as pd
import asyncio
import nest_asyncio
import requests
from datetime import datetime, timezone

interval = '5m'  # 5-minute candlesticks

# Initialize binance client (used only for data fetching)
binance = ccxt.binance({
    'enableRateLimit': True,
    # You can leave apiKey/secret empty if you only fetch public data
    # 'apiKey': config.API_KEY,
    # 'secret': config.SECRET,
})

# Dictionary to store the last sent signal type per symbol (to avoid duplicates)
last_signals = {}

# Fetch USDT perpetual futures symbols dynamically from Binance
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()

    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT' 
        and s['contractType'] == 'PERPETUAL'
        and s['status'] == 'TRADING'
    ]
    print(f"Loaded {len(SELECTED_SYMBOLS)} USDT perpetual symbols")
except requests.exceptions.RequestException as e:
    print(f"Error fetching futures symbols: {e}")
    SELECTED_SYMBOLS = []

# Function to get historical candlestick data
def get_historical_data(symbol, interval, limit=20):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Function to get current day's open price (from daily candles)
def get_day_open_price(symbol):
    day_ohlcv = binance.fetch_ohlcv(symbol, '1d', limit=3)
    df_day = pd.DataFrame(day_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df_day['timestamp'] = pd.to_datetime(df_day['timestamp'], unit='ms')
    df_day.set_index('timestamp', inplace=True)
    # Use close of previous daily candle as "day open" reference
    day_open_price = df_day['close'].iloc[-2]
    return day_open_price

# Simple SMA
def calculate_sma(df, period):
    return df['close'].rolling(window=period).mean()

# Check if short SMA crossed above/below day-open reference
def check_sma_crossover_vs_day_open(df, day_open_price, short_period=3):
    df['sma_short'] = calculate_sma(df, short_period)
    cross_over  = df['sma_short'].iloc[-2] > day_open_price
    cross_under = df['sma_short'].iloc[-2] < day_open_price
    return cross_over, cross_under

# Previous day amplitude ratio (high/low)
def get_previous_day_amplitude(symbol):
    daily_ohlcv = binance.fetch_ohlcv(symbol, '1d', limit=5)
    df_daily = pd.DataFrame(daily_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df_daily['timestamp'] = pd.to_datetime(df_daily['timestamp'], unit='ms')
    df_daily.set_index('timestamp', inplace=True)
    
    prev_day_high = df_daily['high'].iloc[-2]
    prev_day_low  = df_daily['low'].iloc[-2]
    amplitude_ratio = prev_day_high / prev_day_low
    return amplitude_ratio

# Send signal to Binance webhook
def send_binance_signal(symbol, side, close_price):
    # Prevent sending the same signal repeatedly
    key = f"{symbol}_{side}"
    if last_signals.get(key) == close_price:
        return  # same signal already sent at this price level

    timestamp = datetime.now(timezone.utc).isoformat()
    
    payload = {
        "symbol": symbol,                     # e.g. BTCUSDT
        "side": side.upper(),                 # BUY or SELL
        "positionSide": "BOTH",
        "investmentType": "notional_value",
        "amount": "10",
        "price": str(close_price),
        "reduceOnly": False,
        "positionMode": "one_way_mode",
        "signalId": "c8c565bf-ea6b-4a76-93d8-76fd0d6900d0",
        "uid": "30a07ee161389902638c30aeed695061035924de7c970f76b14ba6088aaaa7b8"
    }

    try:
        response = requests.post(
            "https://cb.binanceapi.com/webhook/tv/handle-signal",
            json=payload,
            timeout=10
        )

        if response.status_code in (200, 201):
            print(f"[{timestamp}] SUCCESS → {symbol} {side} @ {close_price}")
            last_signals[key] = close_price
        else:
            print(f"[{timestamp}] FAILED {symbol} {side} → {response.status_code} {response.text[:200]}")

    except requests.RequestException as e:
        print(f"[{timestamp}] Request error {symbol} {side}: {e}")

# ────────────────────────────────────────────────
async def main():
    if not SELECTED_SYMBOLS:
        print("No symbols loaded. Exiting.")
        return

    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                df = get_historical_data(symbol, interval, limit=25)
                if len(df) < 10:
                    continue

                day_open = get_day_open_price(symbol)
                cross_over, cross_under = check_sma_crossover_vs_day_open(df, day_open)

                close_price = df['close'].iloc[-1]
                amplitude_ratio = get_previous_day_amplitude(symbol)

                if amplitude_ratio >= 1.08:
                    if cross_over:
                        send_binance_signal(symbol, "buy", close_price)
                    elif cross_under:
                        send_binance_signal(symbol, "sell", close_price)
                # else:
                #     print(f"{symbol} — prev day range too small ({amplitude_ratio:.4f})")

            except Exception as e:
                print(f"Error {symbol}: {e}")

        await asyncio.sleep(300)  # ≈ 5 minutes

# Allow nested event loops (useful in Jupyter/colab)
nest_asyncio.apply()

if __name__ == "__main__":
    asyncio.run(main())
