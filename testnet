# bot.py
# Binance USDS-M Futures ‚Äì Telegram controlled bot
# Strategy: SMA(14) direction entry + RSI direction exit/reverse
# With debug logging and fixes for cancel errors + re-entry prevention

import time
import logging
import requests
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Dict, Set, Optional
import pandas as pd
import numpy as np
import math
import asyncio
from datetime import datetime, timedelta
from ta.trend import WMAIndicator
from ta.momentum import RSIIndicator

from telegram import Update, Bot
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Config
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg  = config.get("binance",  {})
telegram_cfg = config.get("telegram", {})
trading_cfg  = config.get("trading",  {})

API_KEY    = binance_cfg.get("api_key")
API_SECRET = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")
TELEGRAM_CHAT_ID = telegram_cfg.get("chat_id")

USE_TESTNET = trading_cfg.get("use_testnet", True)

if USE_TESTNET:
    BASE_URL = "https://testnet.binancefuture.com"
    print("=== TESTNET MODE ===")
else:
    BASE_URL = "https://fapi.binance.com"
    print("=== MAINNET ‚Äì REAL MONEY ===")

FIXED_LEVERAGE   = 5
FIXED_MARGIN_TYPE = "ISOLATED"
CHECK_INTERVAL_SECONDS = 60
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -10.0)
TAKE_PROFIT_PCT        = 0.006   # 0.6%
STOP_LOSS_PCT          = 0.009   # 0.9%

if not all([API_KEY, API_SECRET, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID]):
    print("ERROR: Missing keys/token/chat_id")
    exit(1)

HEADERS = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s  %(levelname)-8s  %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# State
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

monitored_symbols: Set[str] = set()
configured: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}
symbol_entry_price: Dict[str, Optional[float]] = {}
symbol_tp_order_id: Dict[str, Optional[int]] = {}
symbol_sl_order_id: Dict[str, Optional[int]] = {}
last_entry_time: Dict[str, Optional[datetime]] = {}   # cooldown after close/sync

_price_precision_cache: Dict[str, int] = {}

telegram_bot = Bot(token=TELEGRAM_TOKEN)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram notifications
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def send_telegram(msg: str, silent: bool = True):
    try:
        await telegram_bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=msg,
            disable_notification=silent
        )
    except Exception as e:
        logger.error(f"Telegram send failed: {e}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Binance helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def signed_request(method: str, endpoint: str, params: Dict = None) -> dict:
    if params is None: params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000
    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        elif method.upper() == "DELETE":
            r = requests.delete(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()
        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {endpoint}: {data}")
            return data
        return data
    except Exception as e:
        logger.error(f"Request failed {endpoint}: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None: params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed {endpoint}: {e}")
        return []

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict): return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            return s.get("contractType") == "PERPETUAL" and s.get("status") == "TRADING"
    return False

def get_price_precision(symbol: str) -> int:
    if symbol in _price_precision_cache:
        return _price_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f.get("tickSize", "0.0001"))
                    prec = max(0, -int(math.log10(tick))) if tick > 0 else 4
                    _price_precision_cache[symbol] = prec
                    return prec
    _price_precision_cache[symbol] = 4
    return 4

def ensure_leverage_and_margin(symbol: str) -> bool:
    if symbol in configured: return True
    pos_data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if not isinstance(pos_data, list) or not pos_data: return False
    pos = pos_data[0]
    lev_ok = int(pos.get("leverage", 0)) == FIXED_LEVERAGE
    margin_ok = pos.get("isolated", False) == (FIXED_MARGIN_TYPE == "ISOLATED")

    success = True
    if not lev_ok:
        r = signed_request("POST", "/fapi/v1/leverage", {"symbol": symbol, "leverage": FIXED_LEVERAGE})
        success &= "code" not in r or r["code"] >= 0
    if not margin_ok:
        r = signed_request("POST", "/fapi/v1/marginType", {"symbol": symbol, "marginType": FIXED_MARGIN_TYPE})
        success &= "code" not in r or r["code"] >= 0
    if success:
        configured.add(symbol)
        logger.info(f"{symbol}: {FIXED_LEVERAGE}x Isolated set")
    return success

def get_current_position_data(symbol: str) -> dict:
    data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(data, list) and data:
        pos = data[0]
        if abs(float(pos.get("positionAmt", "0"))) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        amt = float(pos.get("positionAmt", "0"))
        real_side = "LONG" if amt > 0 else "SHORT"
    current = symbol_position_state.get(symbol)
    if real_side != current:
        logger.info(f"Sync {symbol}: {current or 'None'} ‚Üí {real_side or 'None'} | external change")
        cancel_take_profit(symbol)
        cancel_stop_loss(symbol)
        symbol_position_state[symbol] = real_side
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        symbol_sl_order_id[symbol] = None
        last_entry_time[symbol] = datetime.utcnow()  # cooldown start

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    return float(data.get("markPrice", 0)) if isinstance(data, dict) else 0.0

def get_klines(symbol: str, interval: str, limit: int = 500) -> list:
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params={
            "symbol": symbol, "interval": interval, "limit": limit
        }, timeout=12)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines {symbol} {interval}: {e}")
        return []

def calculate_safe_quantity(symbol: str) -> float:
    data = public_get("/fapi/v1/exchangeInfo")
    min_notional = 5.0
    step_size = 0.001
    min_qty = 0.001
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    min_qty = float(f["minQty"])
                    step_size = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    min_notional = float(f.get("notional", 5.0))
            break
    price = get_current_price(symbol)
    if price <= 0: return 0.0
    target_usdt = min_notional * 1.1
    raw_qty = target_usdt / price
    steps = math.ceil(raw_qty / step_size)
    qty = max(steps * step_size, min_qty)
    return round(qty, 6)

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> dict:
    if qty <= 0: return {"error": "Invalid qty"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    logger.info(f"ORDER {side.upper()} {qstr} {symbol} reduce={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_take_profit_order(symbol: str, side: str, qty: float, price: float) -> dict:
    if price <= 0 or qty <= 0: return {"error": "Invalid TP"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    prec = get_price_precision(symbol)
    pstr = f"{price:.{prec}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    logger.info(f"TP {params['side']} {qstr} @ {pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_stop_loss_order(symbol: str, side: str, qty: float, price: float) -> dict:
    if price <= 0 or qty <= 0: return {"error": "Invalid SL"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    prec = get_price_precision(symbol)
    pstr = f"{price:.{prec}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    logger.info(f"SL {params['side']} {qstr} @ {pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def cancel_take_profit(symbol: str) -> bool:
    order_id = symbol_tp_order_id.get(symbol)
    if not order_id: return True
    resp = signed_request("DELETE", "/fapi/v1/order", {"symbol": symbol, "orderId": order_id})
    if "orderId" in resp:
        symbol_tp_order_id[symbol] = None
        return True
    if isinstance(resp, dict) and resp.get("code") in (-2011, -2013):
        logger.info(f"[{symbol}] TP cancel ignored - already gone ({resp.get('msg')})")
        symbol_tp_order_id[symbol] = None
        return True
    logger.warning(f"[{symbol}] TP cancel failed: {resp}")
    return False

def cancel_stop_loss(symbol: str) -> bool:
    order_id = symbol_sl_order_id.get(symbol)
    if not order_id: return True
    resp = signed_request("DELETE", "/fapi/v1/order", {"symbol": symbol, "orderId": order_id})
    if "orderId" in resp:
        symbol_sl_order_id[symbol] = None
        return True
    if isinstance(resp, dict) and resp.get("code") in (-2011, -2013):
        logger.info(f"[{symbol}] SL cancel ignored - already gone ({resp.get('msg')})")
        symbol_sl_order_id[symbol] = None
        return True
    logger.warning(f"[{symbol}] SL cancel failed: {resp}")
    return False

def close_position(symbol: str, reason: str = "manual") -> bool:
    pos = get_current_position_data(symbol)
    if not pos: return True
    amt = float(pos.get("positionAmt", "0"))
    side = "SELL" if amt > 0 else "BUY"
    qty = abs(amt)
    resp = place_market_order(symbol, side, qty, reduce_only=True)
    success = resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED")
    if success:
        cancel_take_profit(symbol)
        cancel_stop_loss(symbol)
        symbol_position_state[symbol] = None
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        symbol_sl_order_id[symbol] = None
        last_entry_time[symbol] = datetime.utcnow()
        logger.info(f"Closed {symbol} ({reason})")
        asyncio.create_task(send_telegram(f"Position closed ({reason}): {symbol}"))
    else:
        logger.error(f"Close failed {symbol}: {resp}")
    return success

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HMA
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def hull_moving_average(series: pd.Series, period: int = 9) -> pd.Series:
    half = int(period / 2)
    sqrt_p = int(np.sqrt(period))
    wma_half = WMAIndicator(series, window=half).wma()
    wma_full = WMAIndicator(series, window=period).wma()
    raw = 2 * wma_half - wma_full
    hma = WMAIndicator(raw, window=sqrt_p).wma()
    return hma

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram commands
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "SMA direction + RSI exit bot\n"
        "LONG: SMA rising\n"
        "SHORT: SMA falling\n"
        "Exit LONG: RSI falling ‚Üí SHORT\n"
        "Exit SHORT: RSI rising ‚Üí LONG\n"
        "Commands:\n/add SYMBOL\n/rem SYMBOL\n/reset\n/list"
    )

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add BTCUSDT")
        return
    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT perps")
        return
    if not symbol_is_valid_perp(sym):
        await update.message.reply_text(f"{sym} invalid/not trading")
        return
    if sym in monitored_symbols:
        await update.message.reply_text(f"{sym} already monitored")
        return
    if ensure_leverage_and_margin(sym):
        monitored_symbols.add(sym)
        symbol_position_state[sym] = None
        await update.message.reply_text(f"Added {sym}")
    else:
        await update.message.reply_text(f"Failed to set leverage/margin {sym}")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        closed = [sym for sym in list(monitored_symbols) if close_position(sym, "reset")]
        old = sorted(monitored_symbols)
        monitored_symbols.clear()
        symbol_position_state.clear()
        symbol_entry_price.clear()
        symbol_tp_order_id.clear()
        symbol_sl_order_id.clear()
        configured.clear()
        last_entry_time.clear()
        text = "Full reset.\n"
        if old: text += f"Removed: {', '.join(old)}\n"
        if closed: text += f"Closed: {', '.join(closed)}"
        await update.message.reply_text(text)
        return

    sym = context.args[0].strip().upper()
    if sym not in monitored_symbols:
        await update.message.reply_text(f"{sym} not monitored")
        return
    closed = close_position(sym, "manual remove")
    monitored_symbols.remove(sym)
    symbol_position_state.pop(sym, None)
    symbol_entry_price.pop(sym, None)
    symbol_tp_order_id.pop(sym, None)
    symbol_sl_order_id.pop(sym, None)
    configured.discard(sym)
    last_entry_time.pop(sym, None)
    msg = f"Removed {sym}"
    if closed: msg += " + closed position"
    await update.message.reply_text(f"{msg}\nNow: {', '.join(sorted(monitored_symbols)) or 'none'}")

async def cmd_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not monitored_symbols:
        await update.message.reply_text("No symbols monitored.")
        return
    lines = ["Monitored:"]
    for sym in sorted(monitored_symbols):
        side = symbol_position_state.get(sym, "‚Äî")
        lines.append(f"  {sym:10}  {side}")
    await update.message.reply_text("\n".join(lines))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Trading loop
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def trading_loop(_: Application) -> None:
    logger.info(f"Started ‚Äì {len(monitored_symbols)} symbols")
    await send_telegram("Bot started ‚Äì cooldown & cancel fixes active", silent=False)

    while True:
        if not monitored_symbols:
            await asyncio.sleep(CHECK_INTERVAL_SECONDS)
            continue

        for symbol in list(monitored_symbols):
            try:
                sync_position_state(symbol)
                current_side = symbol_position_state.get(symbol)

                pos = get_current_position_data(symbol)  # re-check after sync
                if not pos:
                    if current_side is not None:
                        logger.info(f"[{symbol}] Position gone after sync - cleaned")
                        symbol_position_state[symbol] = None
                        symbol_entry_price[symbol] = None
                        symbol_tp_order_id[symbol] = None
                        symbol_sl_order_id[symbol] = None
                    continue

                pnl = float(pos.get("unRealizedProfit", 0))
                if pnl < MAX_ALLOWED_LOSS_USDT:
                    logger.warning(f"[{symbol}] LOSS CUT | PnL {pnl:.2f}")
                    close_position(symbol, "max loss cut")
                    await send_telegram(f"‚ö†Ô∏è LOSS CUT {symbol} PnL: {pnl:.2f} USDT")
                    continue

                qty = calculate_safe_quantity(symbol)
                if qty < 1e-5:
                    logger.info(f"[{symbol}] SKIP ‚Äì qty too small ({qty})")
                    continue

                klines = get_klines(symbol, "1m", 500)
                if not klines or len(klines) < 200:
                    logger.info(f"[{symbol}] SKIP ‚Äì insufficient klines")
                    continue

                df = pd.DataFrame(klines, columns=[
                    "ot","open","high","low","close","vol",
                    "ct","qv","n","tbv","tqv","i"
                ])
                df["close"] = df["close"].astype(float)

                hma = hull_moving_average(df["close"], 9)
                rsi = RSIIndicator(hma.dropna(), window=14).rsi()
                sma = rsi.rolling(window=14).mean()

                if len(sma.dropna()) < 50:
                    logger.info(f"[{symbol}] SKIP ‚Äì not enough SMA data")
                    continue

                curr_rsi   = rsi.iloc[-2]
                prev_rsi   = rsi.iloc[-3]
                curr_sma   = sma.iloc[-2]
                prev_sma   = sma.iloc[-3]

                if any(pd.isna(x) for x in [curr_rsi, prev_rsi, curr_sma, prev_sma]):
                    logger.info(f"[{symbol}] SKIP ‚Äì NaN in indicators")
                    continue

                mark_price = get_current_price(symbol)
                if mark_price <= 0:
                    logger.info(f"[{symbol}] SKIP ‚Äì mark price invalid")
                    continue

                sma_rising  = curr_sma > prev_sma
                sma_falling = curr_sma < prev_sma
                rsi_falling = curr_rsi < prev_rsi
                rsi_rising  = curr_rsi > prev_rsi

                logger.info(
                    f"[{symbol}] pos={current_side or 'FLAT'} | "
                    f"RSI {curr_rsi:5.2f} ‚Üê {prev_rsi:5.2f} | "
                    f"SMA {curr_sma:6.2f} ‚Üê {prev_sma:6.2f} | "
                    f"mark {mark_price:.4f}"
                )

                # Cooldown check
                can_enter = True
                if symbol in last_entry_time and last_entry_time[symbol]:
                    if datetime.utcnow() - last_entry_time[symbol] < timedelta(seconds=90):
                        can_enter = False
                        logger.info(f"[{symbol}] SKIP entry - cooldown active")

                # ‚îÄ‚îÄ‚îÄ New position ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if current_side is None and can_enter:
                    if sma_rising:
                        logger.info(f"[{symbol}] TRIGGER LONG ‚Äì SMA rising")
                        resp = place_market_order(symbol, "BUY", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "LONG"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 - STOP_LOSS_PCT)
                            tp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                            sl = place_stop_loss_order(symbol, "LONG", qty, sl_price)
                            if "orderId" in tp: symbol_tp_order_id[symbol] = tp["orderId"]
                            if "orderId" in sl: symbol_sl_order_id[symbol] = sl["orderId"]
                            msg = f"üü¢ LONG {symbol} @ {mark_price:.4f} TP {tp_price:.4f} SL {sl_price:.4f}"
                            logger.info(msg)
                            await send_telegram(msg, silent=False)
                            last_entry_time[symbol] = datetime.utcnow()
                        else:
                            logger.error(f"[{symbol}] LONG order failed: {resp}")
                    elif sma_falling:
                        logger.info(f"[{symbol}] TRIGGER SHORT ‚Äì SMA falling")
                        resp = place_market_order(symbol, "SELL", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "SHORT"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 + STOP_LOSS_PCT)
                            tp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                            sl = place_stop_loss_order(symbol, "SHORT", qty, sl_price)
                            if "orderId" in tp: symbol_tp_order_id[symbol] = tp["orderId"]
                            if "orderId" in sl: symbol_sl_order_id[symbol] = sl["orderId"]
                            msg = f"üî¥ SHORT {symbol} @ {mark_price:.4f} TP {tp_price:.4f} SL {sl_price:.4f}"
                            logger.info(msg)
                            await send_telegram(msg, silent=False)
                            last_entry_time[symbol] = datetime.utcnow()
                        else:
                            logger.error(f"[{symbol}] SHORT order failed: {resp}")
                    else:
                        logger.info(f"[{symbol}] NO ENTRY ‚Äì SMA neutral")

                # ‚îÄ‚îÄ‚îÄ Exit / Reverse ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif current_side == "LONG":
                    if rsi_falling:
                        logger.info(f"[{symbol}] TRIGGER EXIT LONG ‚Äì RSI falling")
                        close_position(symbol, "rsi falling")
                        await send_telegram(f"üîÑ {symbol} LONG ‚Üí SHORT (RSI ‚Üì)")
                        resp = place_market_order(symbol, "SELL", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "SHORT"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 + STOP_LOSS_PCT)
                            tp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                            sl = place_stop_loss_order(symbol, "SHORT", qty, sl_price)
                            if "orderId" in tp: symbol_tp_order_id[symbol] = tp["orderId"]
                            if "orderId" in sl: symbol_sl_order_id[symbol] = sl["orderId"]
                            msg = f"üî¥ SHORT {symbol} @ {mark_price:.4f} (reversal)"
                            await send_telegram(msg, silent=False)
                            last_entry_time[symbol] = datetime.utcnow()
                    else:
                        logger.info(f"[{symbol}] NO EXIT LONG ‚Äì RSI not falling")

                elif current_side == "SHORT":
                    if rsi_rising:
                        logger.info(f"[{symbol}] TRIGGER EXIT SHORT ‚Äì RSI rising")
                        close_position(symbol, "rsi rising")
                        await send_telegram(f"üîÑ {symbol} SHORT ‚Üí LONG (RSI ‚Üë)")
                        resp = place_market_order(symbol, "BUY", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "LONG"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 - STOP_LOSS_PCT)
                            tp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                            sl = place_stop_loss_order(symbol, "LONG", qty, sl_price)
                            if "orderId" in tp: symbol_tp_order_id[symbol] = tp["orderId"]
                            if "orderId" in sl: symbol_sl_order_id[symbol] = sl["orderId"]
                            msg = f"üü¢ LONG {symbol} @ {mark_price:.4f} (reversal)"
                            await send_telegram(msg, silent=False)
                            last_entry_time[symbol] = datetime.utcnow()
                    else:
                        logger.info(f"[{symbol}] NO EXIT SHORT ‚Äì RSI not rising")

                # ‚îÄ‚îÄ‚îÄ TP/SL hit detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if current_side is not None and symbol_entry_price.get(symbol) is not None:
                    if float(pos.get("positionAmt", "0")) == 0:
                        entry = symbol_entry_price[symbol]
                        exit_price = float(pos.get("markPrice", mark_price))
                        pnl_pct = (exit_price - entry) / entry * 100 if current_side == "LONG" else (entry - exit_price) / entry * 100
                        if symbol_tp_order_id.get(symbol):
                            await send_telegram(f"‚úÖ TP hit {symbol} {current_side} | PnL +{pnl_pct:.2f}%")
                        elif symbol_sl_order_id.get(symbol):
                            await send_telegram(f"‚ùå SL hit {symbol} {current_side} | PnL {pnl_pct:.2f}%")
                        else:
                            await send_telegram(f"External close {symbol} {current_side}")
                        symbol_position_state[symbol] = None
                        symbol_entry_price[symbol] = None
                        symbol_tp_order_id[symbol] = None
                        symbol_sl_order_id[symbol] = None
                        last_entry_time[symbol] = datetime.utcnow()

            except Exception as e:
                logger.error(f"[{symbol}] Exception: {e}", exc_info=True)

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Startup
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def on_startup(app: Application) -> None:
    asyncio.create_task(trading_loop(app))
    logger.info("Trading task started")

def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("add",   cmd_add))
    app.add_handler(CommandHandler("rem",   cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))
    app.add_handler(CommandHandler("list",  cmd_list))
    app.post_init = on_startup
    print("Bot starting...")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
