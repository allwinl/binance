# bot.py
# Binance USDS-M Futures – LONG ↔ SHORT flip test with model fix + fill check
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION

import time
import logging
from datetime import datetime, timezone

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_sdk_derivatives_trading_usds_futures.rest_api.models import NewOrderSideEnum
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # needs API_KEY, API_SECRET

# ─── Config ─────────────────────────────────────────────────────────────────
RUN_LOOP          = True
SYMBOL            = "XRPUSDT"
QUANTITY          = 5.0
LEVERAGE          = 5
SLEEP_AFTER_CYCLE = 20
ORDER_WAIT        = 12.0
USE_TEST_ORDER    = True  # Set False for real orders

logging.basicConfig(
    filename='flip_test_debug.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

print(">>> LIVE TRADING – REAL MONEY – EXTREME CAUTION <<<")
print(f">>> Flip: LONG ↔ SHORT | {SYMBOL} @ {LEVERAGE}x | qty {QUANTITY} <<<")
if USE_TEST_ORDER:
    print(">>> USING TEST MODE (no real execution) – orders simulated only <<<")
logger.info("BOT STARTED – FIXED FOR MODEL OBJECTS")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol=None):
    qty = 0.0
    used = "none"
    raw_samples = []

    for ep in ['position_information_v3', 'position_information_v2']:
        try:
            method = getattr(client.rest_api, ep)
            resp = method() if symbol is None else method(symbol=symbol)
            data = resp.data() if hasattr(resp, 'data') and callable(getattr(resp, 'data')) else resp

            raw_samples.append((ep, data))

            if isinstance(data, list):
                if symbol:
                    for pos in data:
                        if getattr(pos, 'symbol', '') == symbol:
                            amt_str = getattr(pos, 'positionAmt', '0')
                            qty = float(amt_str)
                            used = ep
                            print(f"{symbol} in {ep}: positionAmt = {amt_str} | side={getattr(pos, 'positionSide', 'N/A')}")
                            break
                else:
                    for pos in data:
                        if getattr(pos, 'symbol', '') == SYMBOL:
                            amt_str = getattr(pos, 'positionAmt', '0')
                            qty = float(amt_str)
                            used = ep + " (all)"
                            print(f"{SYMBOL} in all ({ep}): positionAmt = {amt_str}")
                            break
                    print(f"All positions: {len(data)} items")
                    if data:
                        print(f"Sample (first): {data[0]}")

            if qty != 0.0:
                break
        except Exception as e:
            print(f"{ep} error: {e}")
            logger.error(f"{ep}: {e}")

    if qty == 0.0 and raw_samples:
        print("Position 0 – last raw:")
        ep, d = raw_samples[-1]
        print(f"  {ep}: type={type(d)}, len={len(d) if isinstance(d, list) else 'N/A'}")
        if isinstance(d, list) and d:
            print(f"  Sample item: {d[0]}")

    print(f"Detected: {qty:+.1f} ({used})")
    return qty


def get_futures_balance():
    try:
        resp = client.rest_api.balance_v2()  # /fapi/v2/balance
        data = resp.data() if hasattr(resp, 'data') and callable(getattr(resp, 'data')) else resp
        if isinstance(data, list):
            for asset in data:
                if getattr(asset, 'asset', '') == 'USDT':
                    print(f"USDT Futures Balance:")
                    print(f"  Wallet: {getattr(asset, 'balance', 'N/A')}")
                    print(f"  Available: {getattr(asset, 'availableBalance', 'N/A')}")
                    print(f"  Cross Wallet: {getattr(asset, 'crossWalletBalance', 'N/A')}")
                    return
        print("No USDT in balance response")
    except Exception as e:
        print(f"Balance check failed: {e}")


def send_market_order(symbol, side_enum, qty_float: float):
    qty = round(abs(qty_float), 0)
    if qty < 1:
        print("Qty too small")
        return False

    params = {
        "symbol": symbol,
        "side": side_enum.value,
        "type": "MARKET",
        "quantity": qty,
    }

    endpoint = 'new_order_test' if USE_TEST_ORDER else 'new_order'
    try:
        method = getattr(client.rest_api, endpoint)
        response = method(**params)
        data = response.data() if hasattr(response, 'data') and callable(getattr(response, 'data')) else response

        order_id = getattr(data, 'orderId', None) or data.get('orderId') if isinstance(data, dict) else None
        print(f"{'TEST ' if USE_TEST_ORDER else ''}ORDER → {side_enum.name} {qty} {symbol} | ID: {order_id or 'N/A'}")

        if not order_id and not USE_TEST_ORDER:
            print("No orderId – failed")
            return False

        if USE_TEST_ORDER:
            print("Test order succeeded (simulated)")
            time.sleep(ORDER_WAIT)
            return True

        # Real order: status check
        time.sleep(3)
        try:
            status_resp = client.rest_api.order_information(symbol=symbol, orderId=order_id)
            s_data = status_resp.data() if hasattr(status_resp, 'data') else status_resp
            status = getattr(s_data, 'status', 'UNKNOWN') or s_data.get('status')
            print(f"Status: {status}")
            if status != 'FILLED':
                print(f"NOT FILLED ({status}) – check Binance")
                return False
        except Exception as e:
            print(f"Status check fail: {e}")

        time.sleep(ORDER_WAIT - 3)
        return True

    except Exception as e:
        print(f"ORDER FAIL: {e}")
        return False


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    set_leverage(SYMBOL, LEVERAGE)
    get_futures_balance()  # Check if funds available

    try:
        mode = client.rest_api.position_mode()
        dual = mode.data().dualSidePosition if hasattr(mode, 'data') else mode.dualSidePosition
        print(f"Mode: {'Hedge' if dual else 'One-way'}")
    except:
        print("Mode check failed – assume One-way. Verify in app.")

    cycle = 0
    while RUN_LOOP:
        cycle += 1
        print(f"\n=== Cycle {cycle} @ {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')} ===")

        pos = get_position(SYMBOL)

        success = False
        if pos > 0:
            print(f"LONG → flip SHORT (SELL {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["SELL"], QUANTITY)
        elif pos < 0:
            print(f"SHORT → flip LONG (BUY {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)
        else:
            print(f"Flat → LONG (BUY {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)

        time.sleep(2)
        new_pos = get_position(SYMBOL)
        print(f"After: {new_pos:+.1f}")

        if not success or new_pos == pos:
            print("No change / fail – STOPPING. Check Binance manually (orders, positions, balance transfer).")
            break

        time.sleep(SLEEP_AFTER_CYCLE)

    print("Stopped.")
