# bot.py
# Binance USDS-M Futures bot – REAL MAINNET – single file (REST only)

import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
import math
import sys

from typing import Dict, Any, Optional

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    sys.exit(1)

binance_cfg = config.get("binance", {})
trading_cfg = config.get("trading", {})

API_KEY     = binance_cfg.get("api_key")
API_SECRET  = binance_cfg.get("api_secret")

SYMBOL           = trading_cfg.get("symbol", "XRPUSDT")
LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QUANTITY = trading_cfg.get("default_quantity", 50.0)  # ↑ for XRPUSDT safety

if not API_KEY or not API_SECRET:
    print("ERROR: api_key/api_secret missing in config.yaml")
    sys.exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

symbol_precision = {"quantity": 3, "price": 2}
symbol_filters   = {}

def signed_request(method: str, endpoint: str, params: Optional[dict] = None, max_retries: int = 3) -> dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    query = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), query.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{query}&signature={sig}"

    for attempt in range(1, max_retries + 1):
        try:
            if method.upper() == "GET":
                r = requests.get(url, headers=HEADERS, timeout=10)
            elif method.upper() == "POST":
                r = requests.post(url, headers=HEADERS, timeout=10)
            else:
                raise ValueError("Unsupported method")

            r.raise_for_status()
            data = r.json()

            for h in r.headers:
                if "X-MBX-USED-WEIGHT" in h or "X-MBX-ORDER-COUNT" in h:
                    print(f"   Rate limit: {h} = {r.headers[h]}")

            if isinstance(data, dict) and "code" in data and data["code"] < 0:
                print(f"API ERROR {data['code']}: {data.get('msg', 'no message')}")
            return data
        except Exception as e:
            print(f"Request failed (attempt {attempt}): {str(e)}")
            time.sleep(attempt * 2)
    return {"error": "Max retries exceeded"}

def load_symbol_info():
    global symbol_precision, symbol_filters
    try:
        ex = requests.get(f"{BASE_URL}/fapi/v1/exchangeInfo", timeout=8).json()
        for s in ex.get("symbols", []):
            if s["symbol"] == SYMBOL:
                for f in s.get("filters", []):
                    ft = f["filterType"]
                    if ft == "LOT_SIZE":
                        step = float(f["stepSize"])
                        symbol_precision["quantity"] = -int(round(math.log10(step)))
                        symbol_filters["stepSize"] = step
                        symbol_filters["minQty"]   = float(f["minQty"])
                    if ft == "PRICE_FILTER":
                        symbol_precision["price"] = -int(round(math.log10(float(f["tickSize"]))))
                    if ft == "MIN_NOTIONAL":
                        symbol_filters["minNotional"] = float(f.get("notional", f.get("minNotional", 5.0)))
                print(f"Loaded {SYMBOL}: qty prec={symbol_precision['quantity']}, price prec={symbol_precision['price']}")
                print(f"  minQty={symbol_filters.get('minQty')}, stepSize={symbol_filters.get('stepSize')}")
                print(f"  minNotional ≈ {symbol_filters.get('minNotional', 'unknown')} USDT")
                return
        print("Symbol not found → defaults used")
    except Exception as e:
        print(f"exchangeInfo failed: {e}")

def format_qty(qty: float) -> str:
    p = symbol_precision["quantity"]
    s = f"{qty:.{p}f}"
    return s.rstrip("0").rstrip(".") if "." in s else s

def confirm_action(msg: str) -> bool:
    ans = input(f"{msg}\nConfirm? [y/N]: ").strip().lower()
    return ans in ("y", "yes")

def market_order(side: str, qty: Optional[float] = None, reduce_only: bool = False, quiet: bool = False) -> dict:
    qty = qty or DEFAULT_QUANTITY
    qty_str = format_qty(qty)

    prompt = f"MARKET {side.upper()} {qty_str} {SYMBOL} (reduceOnly={reduce_only})"
    if not quiet and not confirm_action(prompt):
        print("→ Cancelled by user")
        return {"cancelled": True}

    params = {
        "symbol": SYMBOL,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qty_str,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    print(f"→ Sending order: {prompt}")
    return signed_request("POST", "/fapi/v1/order", params)

def check_position_after_order():
    time.sleep(2)  # give time to fill
    pos = get_position(SYMBOL)
    if pos:
        amt = float(pos["positionAmt"])
        side_str = "LONG" if amt > 0 else "SHORT"
        print(f"Position after order: {side_str} | amt: {amt:.{symbol_precision['quantity']}f} | entry: {float(pos['entryPrice']):.4f} | PnL: {float(pos['unRealizedProfit']):+.2f}")
    else:
        print("No position detected after order attempt – check Binance manually")

# ... (keep get_usdt_balance, get_position, get_position_mode, setup_symbol as before – assume they are defined)

def long_cycle(qty=None):
    if get_position_mode() == "HEDGE":
        print("ERROR: Hedge mode – cycles expect One-way")
        return
    qty = qty or DEFAULT_QUANTITY
    print("=== LONG cycle ===")
    res = market_order("BUY", qty, False)
    print(res)
    if "orderId" in res:
        check_position_after_order()
        close_res = market_order("SELL", None, True, quiet=True)
        print("Close result:", close_res)
        check_position_after_order()
    else:
        print("Open failed – aborting cycle")

def short_cycle(qty=None):
    if get_position_mode() == "HEDGE":
        print("ERROR: Hedge mode – cycles expect One-way")
        return
    qty = qty or DEFAULT_QUANTITY
    print("=== SHORT cycle ===")
    res = market_order("SELL", qty, False)
    print(res)
    if "orderId" in res:
        check_position_after_order()
        close_res = market_order("BUY", None, True, quiet=True)
        print("Close result:", close_res)
        check_position_after_order()
    else:
        print("Open failed – aborting cycle")

def print_help():
    print(f"""
Loaded {SYMBOL} info OK
Commands:

  python bot.py balance           → available USDT (futures wallet!)
  python bot.py positions         → current positions
  python bot.py setup             → set leverage + margin type
  python bot.py buy  [qty]        → open LONG (market)
  python bot.py sell [qty]        → open SHORT (market)
  python bot.py long_cycle  [qty] → open LONG → auto close
  python bot.py short_cycle [qty] → open SHORT → auto close
  python bot.py time              → server time
  python bot.py precision         → precision info
  python bot.py mode              → One-way or Hedge?

No args → this help
""")

if __name__ == "__main__":
    load_symbol_info()

    args = sys.argv[1:]
    if not args:
        print_help()
        sys.exit(0)

    cmd = args[0].lower()
    qty_arg = float(args[1]) if len(args) > 1 else None

    if cmd == "balance":
        print(f"Available USDT (futures): {get_usdt_balance():.2f}")

    elif cmd == "positions":
        # assume get_positions() or similar – print active ones

    elif cmd == "setup":
        setup_symbol()

    elif cmd == "buy":
        res = market_order("BUY", qty_arg, False)
        print(res)
        check_position_after_order()

    elif cmd == "sell":
        res = market_order("SELL", qty_arg, False)
        print(res)
        check_position_after_order()

    elif cmd == "long_cycle":
        long_cycle(qty_arg)

    elif cmd == "short_cycle":
        short_cycle(qty_arg)

    elif cmd == "time":
        data = requests.get(f"{BASE_URL}/fapi/v1/time").json()
        ts = data.get("serverTime", 0)
        print(f"Server time: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime(ts / 1000))}")

    elif cmd == "precision":
        print(f"Qty: {symbol_precision['quantity']} dec | Price: {symbol_precision['price']} dec")

    elif cmd == "mode":
        mode = get_position_mode()
        print(f"Mode: {mode}")

    else:
        print(f"Unknown command '{cmd}'")
        print_help()
