# bot.py
# Binance USDS-M Futures bot – REAL MAINNET – single file

import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Dict, Any, Optional
import math
import sys

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    sys.exit(1)

binance_cfg = config.get("binance", {})
trading_cfg = config.get("trading", {})

API_KEY     = binance_cfg.get("api_key")
API_SECRET  = binance_cfg.get("api_secret")

SYMBOL           = trading_cfg.get("symbol", "BTCUSDT")
LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QUANTITY = trading_cfg.get("default_quantity", 0.001)

if not API_KEY or not API_SECRET:
    print("ERROR: api_key/api_secret missing")
    sys.exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

symbol_precision = {"quantity": 3, "price": 2}
symbol_filters   = {}  # will store minQty, stepSize, minNotional

def signed_request(method: str, endpoint: str, params: Optional[Dict] = None, max_retries: int = 3) -> Dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    query = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), query.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{query}&signature={sig}"

    for attempt in range(1, max_retries + 1):
        try:
            if method.upper() == "GET":
                r = requests.get(url, headers=HEADERS, timeout=10)
            elif method.upper() == "POST":
                r = requests.post(url, headers=HEADERS, timeout=10)
            else:
                raise ValueError("Bad method")

            r.raise_for_status()
            data = r.json()

            for h in r.headers:
                if "X-MBX-USED-WEIGHT" in h or "X-MBX-ORDER-COUNT" in h:
                    print(f"   {h}: {r.headers[h]}")

            if isinstance(data, dict) and "code" in data and data["code"] < 0:
                print(f"API ERROR: {data['code']} - {data.get('msg', 'no msg')}")
                if data["code"] in (-1001, -1003, -1008):
                    time.sleep(attempt * 2)
                    continue
            return data
        except Exception as e:
            print(f"Request failed (try {attempt}): {e}")
            time.sleep(attempt * 2)
    return {"error": "max retries"}

def load_symbol_info():
    global symbol_precision, symbol_filters
    try:
        ex = requests.get(f"{BASE_URL}/fapi/v1/exchangeInfo", timeout=8).json()
        for s in ex.get("symbols", []):
            if s["symbol"] == SYMBOL:
                for f in s.get("filters", []):
                    ft = f["filterType"]
                    if ft == "LOT_SIZE":
                        symbol_precision["quantity"] = -int(round(math.log10(float(f["stepSize"]))))
                        symbol_filters["stepSize"] = float(f["stepSize"])
                        symbol_filters["minQty"]   = float(f["minQty"])
                    if ft == "PRICE_FILTER":
                        symbol_precision["price"] = -int(round(math.log10(float(f["tickSize"]))))
                    if ft == "MIN_NOTIONAL":
                        symbol_filters["minNotional"] = float(f.get("minNotional", 0))
                print(f"Loaded {SYMBOL}: qty prec={symbol_precision['quantity']}, price prec={symbol_precision['price']}")
                if symbol_filters.get("minQty"):
                    print(f"  minQty={symbol_filters['minQty']}, stepSize={symbol_filters['stepSize']}")
                if symbol_filters.get("minNotional"):
                    print(f"  minNotional≈{symbol_filters['minNotional']} USDT")
                return
        print("Symbol not found in exchangeInfo – using defaults")
    except Exception as e:
        print(f"exchangeInfo failed: {e}")

def format_qty(qty: float) -> str:
    p = symbol_precision["quantity"]
    s = f"{qty:.{p}f}"
    return s.rstrip("0").rstrip(".") if "." in s else s

def confirm_action(msg: str) -> bool:
    ans = input(f"{msg}  Really execute? [y/N]: ").strip().lower()
    return ans in ("y", "yes")

def market_order(side: str, qty: Optional[float] = None, reduce_only: bool = False) -> Dict:
    qty = qty or DEFAULT_QUANTITY
    qty_str = format_qty(qty)

    if not confirm_action(f"Sending MARKET {side.upper()} {qty_str} {SYMBOL} (reduceOnly={reduce_only})"):
        print("Cancelled by user.")
        return {"cancelled": True}

    params = {
        "symbol": SYMBOL,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qty_str,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    print(f"→ Executing: MARKET {side.upper()} {qty_str} {SYMBOL}")
    return signed_request("POST", "/fapi/v1/order", params)

# ... (keep get_usdt_balance, get_position, get_position_mode, setup_symbol as before)

def long_cycle(qty=None):
    if get_position_mode() == "HEDGE":
        print("Hedge mode → cycle not supported in this version")
        return
    qty = qty or DEFAULT_QUANTITY
    if qty < symbol_filters.get("minQty", 0) * 0.9:
        print(f"Warning: qty {qty} < suggested minQty {symbol_filters.get('minQty')}")
    print("=== LONG cycle ===")
    open_res = market_order("BUY", qty, False)
    print(open_res)
    if "orderId" not in open_res:
        return
    time.sleep(3)
    pos = get_position(SYMBOL)
    if pos and float(pos["positionAmt"]) > 0:
        close_qty = abs(float(pos["positionAmt"]))
        close_res = market_order("SELL", close_qty, True)
        print(close_res)
    else:
        print("No LONG position found after open")

def short_cycle(qty=None):
    if get_position_mode() == "HEDGE":
        print("Hedge mode → cycle not supported")
        return
    qty = qty or DEFAULT_QUANTITY
    print("=== SHORT cycle ===")
    open_res = market_order("SELL", qty, False)
    print(open_res)
    if "orderId" not in open_res:
        return
    time.sleep(3)
    pos = get_position(SYMBOL)
    if pos and float(pos["positionAmt"]) < 0:
        close_qty = abs(float(pos["positionAmt"]))
        close_res = market_order("BUY", close_qty, True)
        print(close_res)
    else:
        print("No SHORT position found after open")

# CLI part remains similar, add to print_help():
#   python bot.py long_cycle [qty]    → open + close LONG
#   python bot.py short_cycle [qty]   → open + close SHORT

if __name__ == "__main__":
    load_symbol_info()   # now loads more filter info

    args = sys.argv[1:]
    if not args:
        print_help()  # your current help text
        sys.exit(0)

    cmd = args[0].lower()
    qty_arg = float(args[1]) if len(args) > 1 else None

    if cmd in ("buy", "sell"):
        side = "BUY" if cmd == "buy" else "SELL"
        print(market_order(side, qty_arg, reduce_only=False))
    elif cmd == "long_cycle":
        long_cycle(qty_arg)
    elif cmd == "short_cycle":
        short_cycle(qty_arg)
    # ... other commands (balance, positions, setup, etc.)

    else:
        print(f"Unknown: {cmd}")
        print_help()
