# bot.py
# Binance USDS-M Futures auto-trading bot – ALL perpetual USDT pairs
# Strategy: EMA(14) → RSI(14 on EMA) → SMA(5 on RSI) on 1m
# Entry: SMA(5) direction
# Exit/Reverse: RSI(14) slope reversal
# TP 0.6% (LIMIT) / SL -0.9% (Algo STOP_MARKET + closePosition)
# Checks every 60 seconds
#
# IMPORTANT: SL uses Algo API (/fapi/v1/algo/new) due to 2025 migration
# TESTNET SUPPORT: set USE_TESTNET = True
# ────────────────────────────────────────────────

import time
import logging
import requests
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Dict, Set, Optional
import pandas as pd
import numpy as np
import math
from ta.trend import EMAIndicator
from ta.momentum import RSIIndicator

# ────────────────────────────────────────────────
# Config & Testnet toggle
# ────────────────────────────────────────────────

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg = config.get("binance", {})
trading_cfg = config.get("trading", {})

USE_TESTNET = True          # ← Change to False for real trading!

if USE_TESTNET:
    BASE_URL = "https://testnet.binancefuture.com"
    print("=== RUNNING IN TESTNET MODE ===")
else:
    BASE_URL = "https://fapi.binance.com"
    print("=== RUNNING IN MAINNET MODE – REAL MONEY AT RISK! ===")

API_KEY    = binance_cfg.get("api_key")
API_SECRET = binance_cfg.get("api_secret")

FIXED_LEVERAGE   = 5
FIXED_MARGIN_TYPE = "ISOLATED"
CHECK_INTERVAL_SECONDS = 60
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -15.0)

TAKE_PROFIT_PCT = 0.006    # 0.6%
STOP_LOSS_PCT   = 0.009    # 0.9%

if not API_KEY or not API_SECRET:
    print("ERROR: Missing api_key or api_secret in config.yaml")
    exit(1)

HEADERS = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s  %(levelname)-8s  %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ────────────────────────────────────────────────
# State & caches
# ────────────────────────────────────────────────

monitored_symbols: Set[str] = set()
configured: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}
symbol_entry_price: Dict[str, Optional[float]] = {}
symbol_tp_order_id: Dict[str, Optional[int]] = {}
symbol_sl_algo_id: Dict[str, Optional[int]] = {}  # Now algoId, not orderId

_price_precision_cache: Dict[str, int] = {}
_qty_precision_cache: Dict[str, int] = {}

# ────────────────────────────────────────────────
# Binance helpers
# ────────────────────────────────────────────────

def signed_request(method: str, endpoint: str, params: Dict = None) -> dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        elif method.upper() == "DELETE":
            r = requests.delete(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError(f"Unsupported method: {method}")

        r.raise_for_status()
        data = r.json()

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error | code={data['code']} | msg={data.get('msg')} | endpoint={endpoint}")
        return data
    except Exception as e:
        logger.error(f"Request failed {endpoint}: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None:
        params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed {endpoint}: {e}")
        return []

def get_all_usdt_perp_symbols() -> Set[str]:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return set()
    symbols = set()
    for s in data.get("symbols", []):
        if (s.get("contractType") == "PERPETUAL" and
            s.get("status") == "TRADING" and
            s.get("quoteAsset") == "USDT"):
            symbols.add(s["symbol"])
    return symbols

def get_price_precision(symbol: str) -> int:
    if symbol in _price_precision_cache:
        return _price_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f["tickSize"])
                    prec = max(0, -int(math.log10(tick)))
                    _price_precision_cache[symbol] = prec
                    return prec
    _price_precision_cache[symbol] = 4
    return 4

def get_qty_precision(symbol: str) -> int:
    if symbol in _qty_precision_cache:
        return _qty_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    step = float(f["stepSize"])
                    prec = max(0, -int(math.log10(step)))
                    _qty_precision_cache[symbol] = prec
                    return prec
    _qty_precision_cache[symbol] = 3
    return 3

def ensure_leverage_and_margin(symbol: str) -> bool:
    if symbol in configured:
        return True
    pos_data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if not isinstance(pos_data, list) or not pos_data:
        return False
    pos = pos_data[0]
    current_lev = int(pos.get("leverage", 0))
    current_margin = "ISOLATED" if pos.get("isolated", False) else "CROSSED"
    success = True
    if current_lev != FIXED_LEVERAGE:
        resp = signed_request("POST", "/fapi/v1/leverage", {"symbol": symbol, "leverage": FIXED_LEVERAGE})
        if "code" in resp and resp["code"] < 0:
            success = False
    if current_margin != FIXED_MARGIN_TYPE:
        resp = signed_request("POST", "/fapi/v1/marginType", {"symbol": symbol, "marginType": FIXED_MARGIN_TYPE})
        if "code" in resp and resp["code"] < 0:
            success = False
    if success:
        configured.add(symbol)
        logger.info(f"Configured {symbol}: {FIXED_LEVERAGE}x Isolated")
    return success

def get_current_position_data(symbol: str) -> dict:
    data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(data, list) and data:
        pos = data[0]
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        amt = float(pos.get("positionAmt", "0"))
        real_side = "LONG" if amt > 0 else "SHORT"
    current = symbol_position_state.get(symbol)
    if real_side != current:
        logger.info(f"Position sync {symbol}: {current or 'None'} → {real_side or 'None'}")
        cancel_bracket_orders(symbol)
        symbol_position_state[symbol] = real_side
        symbol_entry_price[symbol] = None

def cancel_bracket_orders(symbol: str) -> None:
    # Cancel TP (legacy orderId)
    tp_id = symbol_tp_order_id.get(symbol)
    if tp_id:
        signed_request("DELETE", "/fapi/v1/order", {"symbol": symbol, "orderId": tp_id})
        symbol_tp_order_id[symbol] = None

    # Cancel SL (algoId)
    sl_algo_id = symbol_sl_algo_id.get(symbol)
    if sl_algo_id:
        signed_request("DELETE", "/fapi/v1/algo/cancel", {"symbol": symbol, "algoId": sl_algo_id})
        symbol_sl_algo_id[symbol] = None

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    return float(data.get("markPrice", 0)) if isinstance(data, dict) else 0.0

def get_klines(symbol: str, interval: str = "1m", limit: int = 200) -> list:
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params={
            "symbol": symbol, "interval": interval, "limit": limit
        }, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines failed {symbol}: {e}")
        return []

def calculate_safe_quantity(symbol: str) -> float:
    data = public_get("/fapi/v1/exchangeInfo")
    min_notional = 5.0
    step_size = 0.001
    min_qty = 0.001
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    min_qty = float(f["minQty"])
                    step_size = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    min_notional = float(f.get("notional", 5.0))
            break
    price = get_current_price(symbol)
    if price <= 0:
        return 0.001
    target_usdt = min_notional * 1.2
    raw_qty = target_usdt / price
    steps = math.ceil(raw_qty / step_size)
    qty = max(steps * step_size, min_qty)
    prec = get_qty_precision(symbol)
    return round(qty, prec)

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> dict:
    if qty <= 0:
        return {"error": "Invalid quantity"}
    prec = get_qty_precision(symbol)
    qstr = f"{qty:.{prec}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    logger.info(f"ORDER {side.upper()} {qstr} {symbol} reduceOnly={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_take_profit_order(symbol: str, side: str, qty: float, price: float) -> dict:
    prec = get_price_precision(symbol)
    pstr = f"{price:.{prec}f}".rstrip("0").rstrip(".")
    qstr = f"{qty:.{get_qty_precision(symbol)}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    logger.info(f"TP {params['side']} {qstr} @ {pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_algo_stop_order(symbol: str, side: str, stop_price: float) -> dict:
    prec = get_price_precision(symbol)
    pstr = f"{stop_price:.{prec}f}".rstrip("0").rstrip(".")

    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "STOP_MARKET",
        "stopPrice": pstr,
        "closePosition": "true",
        "reduceOnly": "true",
        "priceProtect": "true",
        "workingType": "MARK_PRICE",
    }
    logger.info(f"ALGO SL {params['side']} FULL close @ stop={pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/algo/new", params)

def close_position(symbol: str) -> bool:
    pos = get_current_position_data(symbol)
    if not pos:
        return True
    amt = float(pos.get("positionAmt", "0"))
    side = "SELL" if amt > 0 else "BUY"
    qty = abs(amt)
    resp = place_market_order(symbol, side, qty, reduce_only=True)
    success = resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED")
    if success:
        cancel_bracket_orders(symbol)
        symbol_position_state[symbol] = None
        symbol_entry_price[symbol] = None
        logger.info(f"Closed position {symbol}")
    else:
        logger.error(f"Close failed {symbol}: {resp}")
    return success

# ────────────────────────────────────────────────
# Main loop
# ────────────────────────────────────────────────

def main_loop():
    mode = "TESTNET" if USE_TESTNET else "MAINNET"
    logger.info(f"Bot started – {mode} – 1m timeframe – check every {CHECK_INTERVAL_SECONDS}s")

    while True:
        try:
            current_symbols = get_all_usdt_perp_symbols()
            if not current_symbols:
                time.sleep(CHECK_INTERVAL_SECONDS)
                continue

            for sym in current_symbols - monitored_symbols:
                if ensure_leverage_and_margin(sym):
                    monitored_symbols.add(sym)
                    symbol_position_state[sym] = None
                    logger.info(f"Added {sym}")

            for sym in monitored_symbols - current_symbols:
                close_position(sym)
                monitored_symbols.remove(sym)
                symbol_position_state.pop(sym, None)
                symbol_entry_price.pop(sym, None)
                symbol_tp_order_id.pop(sym, None)
                symbol_sl_algo_id.pop(sym, None)
                configured.discard(sym)
                logger.info(f"Removed {sym}")

            for symbol in list(monitored_symbols):
                try:
                    sync_position_state(symbol)
                    current_side = symbol_position_state.get(symbol)

                    pos_data = get_current_position_data(symbol)
                    if pos_data:
                        pnl = float(pos_data.get("unRealizedProfit", 0))
                        if pnl < MAX_ALLOWED_LOSS_USDT:
                            logger.warning(f"[{symbol}] Hard loss cut | PnL {pnl:.2f}")
                            close_position(symbol)
                            continue

                    qty = calculate_safe_quantity(symbol)
                    if qty <= 0.000001:
                        continue

                    klines = get_klines(symbol, "1m", 100)
                    if not klines or len(klines) < 40:
                        continue

                    df = pd.DataFrame(klines, columns=[
                        "ot","open","high","low","close","vol",
                        "ct","qv","n","tbv","tqv","i"
                    ])
                    df["close"] = df["close"].astype(float)

                    ema14 = EMAIndicator(df["close"], window=14).ema_indicator()
                    rsi14 = RSIIndicator(ema14, window=14).rsi()
                    sma5  = rsi14.rolling(window=5).mean()

                    if len(sma5.dropna()) < 3:
                        continue

                    last_sma = sma5.iloc[-2]
                    prev_sma = sma5.iloc[-3]
                    last_rsi = rsi14.iloc[-2]
                    prev_rsi = rsi14.iloc[-3]

                    mark_price = get_current_price(symbol)
                    if mark_price <= 0:
                        continue

                    if current_side is None:
                        if last_sma > prev_sma:
                            logger.info(f"[{symbol}] LONG signal")
                            entry = place_market_order(symbol, "BUY", qty)
                            if entry.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"
                                symbol_entry_price[symbol] = mark_price

                                tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                                sl_price = mark_price * (1 - STOP_LOSS_PCT)

                                tp_resp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                                sl_resp = place_algo_stop_order(symbol, "LONG", sl_price)

                                if "orderId" in tp_resp:
                                    symbol_tp_order_id[symbol] = tp_resp["orderId"]
                                if "algoId" in sl_resp:
                                    symbol_sl_algo_id[symbol] = sl_resp["algoId"]
                                else:
                                    logger.error(f"Algo SL placement FAILED for {symbol} LONG: {sl_resp}")

                                logger.info(f"[{symbol}] LONG @ {mark_price:.6f} | TP {tp_price:.6f} | SL stop {sl_price:.6f}")

                        elif last_sma < prev_sma:
                            logger.info(f"[{symbol}] SHORT signal")
                            entry = place_market_order(symbol, "SELL", qty)
                            if entry.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"
                                symbol_entry_price[symbol] = mark_price

                                tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                                sl_price = mark_price * (1 + STOP_LOSS_PCT)

                                tp_resp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                                sl_resp = place_algo_stop_order(symbol, "SHORT", sl_price)

                                if "orderId" in tp_resp:
                                    symbol_tp_order_id[symbol] = tp_resp["orderId"]
                                if "algoId" in sl_resp:
                                    symbol_sl_algo_id[symbol] = sl_resp["algoId"]
                                else:
                                    logger.error(f"Algo SL placement FAILED for {symbol} SHORT: {sl_resp}")

                                logger.info(f"[{symbol}] SHORT @ {mark_price:.6f} | TP {tp_price:.6f} | SL stop {sl_price:.6f}")

                    elif current_side == "LONG" and last_rsi < prev_rsi:
                        logger.info(f"[{symbol}] LONG → reverse SHORT (RSI ↓)")
                        close_position(symbol)
                        entry = place_market_order(symbol, "SELL", qty)
                        if entry.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "SHORT"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 + STOP_LOSS_PCT)
                            tp_resp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                            sl_resp = place_algo_stop_order(symbol, "SHORT", sl_price)
                            if "orderId" in tp_resp:
                                symbol_tp_order_id[symbol] = tp_resp["orderId"]
                            if "algoId" in sl_resp:
                                symbol_sl_algo_id[symbol] = sl_resp["algoId"]

                    elif current_side == "SHORT" and last_rsi > prev_rsi:
                        logger.info(f"[{symbol}] SHORT → reverse LONG (RSI ↑)")
                        close_position(symbol)
                        entry = place_market_order(symbol, "BUY", qty)
                        if entry.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "LONG"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                            sl_price = mark_price * (1 - STOP_LOSS_PCT)
                            tp_resp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                            sl_resp = place_algo_stop_order(symbol, "LONG", sl_price)
                            if "orderId" in tp_resp:
                                symbol_tp_order_id[symbol] = tp_resp["orderId"]
                            if "algoId" in sl_resp:
                                symbol_sl_algo_id[symbol] = sl_resp["algoId"]

                except Exception as e:
                    logger.error(f"Error processing {symbol}: {e}")

        except Exception as e:
            logger.error(f"Main loop error: {e}")

        time.sleep(CHECK_INTERVAL_SECONDS)

if __name__ == "__main__":
    main_loop()
