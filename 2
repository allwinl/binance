# bot.py
# Binance USDS-M Futures – Simple LONG ↔ SHORT flip test
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION

import time
import logging
from datetime import datetime, timezone

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_sdk_derivatives_trading_usds_futures.rest_api.models import NewOrderSideEnum
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # needs API_KEY, API_SECRET

# ─── Config ─────────────────────────────────────────────────────────────────
RUN_LOOP         = True             # set False to stop
SYMBOL           = "XRPUSDT"
QUANTITY         = 5.0
LEVERAGE         = 5
SLEEP_AFTER_CYCLE = 20              # seconds between full cycles
ORDER_WAIT       = 10.0             # seconds to wait after order for position update

logging.basicConfig(
    filename='flip_test.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

print(">>> LIVE TRADING – REAL MONEY – EXTREME CAUTION <<<")
print(f">>> Flip test: LONG → SHORT → LONG → SHORT... | {SYMBOL} @ {LEVERAGE}x | qty {QUANTITY} <<<")
logger.info("BOT STARTED – SIMPLE LONG/SHORT FLIP TEST")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol):
    qty = 0.0
    used_endpoint = "none"

    for ep in ['position_information_v3', 'position_information_v2']:
        try:
            method = getattr(client.rest_api, ep)
            resp = method(symbol=symbol)
            data = resp.data() if hasattr(resp, 'data') and callable(getattr(resp, 'data')) else resp

            if isinstance(data, list):
                for pos in data:
                    if pos.get('symbol') == symbol:
                        qty = float(pos.get('positionAmt', '0'))
                        used_endpoint = ep
                        break
            if qty != 0.0:
                break
        except Exception as e:
            logger.error(f"{ep} failed: {e}")

    print(f"Position: {qty:+.1f}  (from {used_endpoint})")
    return qty


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        print(f"Leverage set to {lev}x")
        logger.info(f"Leverage set to {lev}x")
    except Exception as e:
        print(f"Leverage set warning: {e}")
        logger.warning(f"Leverage: {e}")


def send_market_order(symbol, side_enum, qty_float: float):
    qty = round(abs(qty_float), 0)
    if qty < 1:
        print("Quantity too small – skip")
        return False

    params = {
        "symbol": symbol,
        "side": side_enum.value,
        "type": "MARKET",
        "quantity": qty,
    }

    try:
        response = client.rest_api.new_order(**params)
        data = response.data() if hasattr(response, 'data') and callable(getattr(response, 'data')) else response

        order_id = data.get('orderId') if isinstance(data, dict) else getattr(data, 'orderId', None)
        print(f"ORDER OK → {side_enum.name} {qty} {symbol}  (ID: {order_id or 'N/A'})")
        logger.info(f"Order success: {side_enum.name} {qty} {symbol}")

        print(f"Waiting {ORDER_WAIT}s for fill...")
        time.sleep(ORDER_WAIT)
        return True

    except Exception as e:
        print(f"ORDER FAILED: {e}")
        logger.error(f"Order failed: {e}")
        return False


# ─── Main Cycle ─────────────────────────────────────────────────────────────

if __name__ == "__main__":
    set_leverage(SYMBOL, LEVERAGE)

    current_direction = "FLAT"  # or "LONG" / "SHORT" – we detect from position

    cycle = 0

    while RUN_LOOP:
        cycle += 1
        print(f"\n=== Cycle {cycle} at {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')} ===")

        pos_qty = get_position(SYMBOL)

        if pos_qty > 0:
            current_direction = "LONG"
            print(f"Closing LONG + opening SHORT (sell {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["SELL"], QUANTITY)

        elif pos_qty < 0:
            current_direction = "SHORT"
            print(f"Closing SHORT + opening LONG (buy {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)

        else:  # flat – start with LONG
            print(f"Flat → opening LONG (buy {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)

        # Optional: quick re-check position after wait
        time.sleep(2)
        new_pos = get_position(SYMBOL)
        print(f"After cycle: position {new_pos:+.1f}")

        # You can uncomment if you want minimal balance check later
        # print_account_status()  # ← define a minimal version if needed

        time.sleep(SLEEP_AFTER_CYCLE)

    print("Loop stopped.")
    logger.info("BOT STOPPED")
