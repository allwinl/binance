# bot.py
# Binance USDS-M Futures Telegram bot – single file
# Commands: /add SYMBOL, /rem SYMBOL, /rem or /reset, plain symbol message → check & trade

import asyncio
import logging
from datetime import datetime, timezone
import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Optional, Dict, Set
import pandas as pd
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# ────────────────────────────────────────────────
# Load config
# ────────────────────────────────────────────────

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg = config.get("binance", {})
telegram_cfg = config.get("telegram", {})
trading_cfg = config.get("trading", {})

API_KEY        = binance_cfg.get("api_key")
API_SECRET     = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")

LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QUANTITY = trading_cfg.get("default_quantity", 0.001)  # keep small!

if not API_KEY or not API_SECRET or not TELEGRAM_TOKEN:
    print("ERROR: Missing api_key, api_secret or telegram token")
    exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Global set of monitored symbols (in-memory, lost on restart)
monitored_symbols: Set[str] = set()

# ────────────────────────────────────────────────
# Binance helpers
# ────────────────────────────────────────────────

def signed_request(method: str, endpoint: str, params: Dict = None) -> Dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {data['code']}: {data.get('msg')}")
        return data
    except Exception as e:
        logger.error(f"Request failed: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None:
        params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed: {e}")
        return []

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol and s["contractType"] == "PERPETUAL" and s["status"] == "TRADING":
            return True
    return False

def get_klines(symbol: str, interval: str, limit: int = 100) -> list:
    return public_get("/fapi/v1/klines", {"symbol": symbol, "interval": interval, "limit": limit})

def place_market_order(symbol: str, side: str, qty: float):
    qstr = f"{qty:.3f}"   # you may want to adjust precision per symbol
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    logger.info(f"Opening {side.upper()} {qstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def close_all_positions():
    # Get all positions
    positions = signed_request("GET", "/fapi/v2/positionRisk")
    if not isinstance(positions, list):
        return {"error": "Failed to get positions"}

    closed = []
    for pos in positions:
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) < 1e-8:
            continue

        sym = pos["symbol"]
        side = "SELL" if amt > 0 else "BUY"
        qty_abs = abs(amt)
        qstr = f"{qty_abs:.3f}"

        params = {
            "symbol": sym,
            "side": side,
            "type": "MARKET",
            "quantity": qstr,
            "reduceOnly": "true"
        }
        logger.info(f"Closing {sym} {side} {qstr}")
        resp = signed_request("POST", "/fapi/v1/order", params)
        closed.append((sym, resp))

    return closed

# ────────────────────────────────────────────────
# Telegram handlers
# ────────────────────────────────────────────────

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Futures EMA9 bot\n\n"
        "Commands:\n"
        "/add SYMBOL     → add symbol to monitor (e.g. /add XRPUSDT)\n"
        "/rem SYMBOL     → remove one symbol\n"
        "/rem or /reset  → clear all symbols + close all positions\n\n"
        "Just send a symbol (XRPUSDT) → check & trade if it's in your list"
    )

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add XRPUSDT")
        return

    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT perpetual symbols are supported")
        return

    if symbol_is_valid_perp(sym):
        if sym in monitored_symbols:
            await update.message.reply_text(f"{sym} is already monitored")
        else:
            monitored_symbols.add(sym)
            await update.message.reply_text(f"Added {sym} to monitoring list\nCurrent list: {', '.join(sorted(monitored_symbols)) or 'empty'}")
    else:
        await update.message.reply_text(f"{sym} is not a valid/trading USDS-M perpetual symbol")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        # /rem or /reset without args → clear all + close positions
        old_list = sorted(monitored_symbols)
        monitored_symbols.clear()

        closed = close_all_positions()

        text = "Cleared all monitored symbols.\n"
        if old_list:
            text += f"Removed: {', '.join(old_list)}\n"
        else:
            text += "List was already empty.\n"

        if closed:
            text += "Closed positions:\n" + "\n".join([f"{s}: {r}" for s, r in closed])
        else:
            text += "No positions were open."

        await update.message.reply_text(text)
        return

    # /rem SYMBOL → remove one
    sym = context.args[0].strip().upper()
    if sym in monitored_symbols:
        monitored_symbols.remove(sym)
        await update.message.reply_text(
            f"Removed {sym}\n"
            f"Current list: {', '.join(sorted(monitored_symbols)) or 'empty'}"
        )
    else:
        await update.message.reply_text(f"{sym} was not in the monitored list")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text.strip().upper()
    if text.startswith(('/', 'HELP')) or len(text) < 4 or not text.endswith("USDT"):
        return  # ignore commands & invalid messages

    symbol = text

    if not monitored_symbols:
        await update.message.reply_text("Your monitored list is empty. Use /add SYMBOL first.")
        return

    if symbol not in monitored_symbols:
        await update.message.reply_text(
            f"{symbol} is not in your monitored list.\n"
            f"Current list: {', '.join(sorted(monitored_symbols))}\n"
            "Use /add to include it."
        )
        return

    await update.message.reply_text(f"Analyzing {symbol}...")

    klines_1m = get_klines(symbol, "1m", 50)
    if not klines_1m or len(klines_1m) < 9:
        await update.message.reply_text("Not enough 1m candles")
        return

    klines_1d = get_klines(symbol, "1d", 2)
    if not klines_1d:
        await update.message.reply_text("Failed to get 1d data")
        return

    today_open = float(klines_1d[-1][1])  # open of current day candle
    closes = [float(k[4]) for k in klines_1m]
    df = pd.DataFrame({"close": closes})
    ema9 = df["close"].ewm(span=9, adjust=False).mean().iloc[-1]

    msg = (
        f"{symbol}\n"
        f"1d open: {today_open:.4f}\n"
        f"EMA-9 (1m): {ema9:.4f}\n"
    )

    if ema9 > today_open:
        msg += "→ EMA9 > 1d open → opening LONG"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "BUY", DEFAULT_QUANTITY)
        await update.message.reply_text(f"Order result:\n{resp}")
    elif ema9 < today_open:
        msg += "→ EMA9 < 1d open → opening SHORT"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "SELL", DEFAULT_QUANTITY)
        await update.message.reply_text(f"Order result:\n{resp}")
    else:
        msg += "→ EMA9 == 1d open → no action"
        await update.message.reply_text(msg)

def main() -> None:
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("add", cmd_add))
    app.add_handler(CommandHandler("rem", cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))  # alias
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("Bot started. Monitored symbols:", monitored_symbols)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
