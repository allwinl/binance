# bot_DIAGNOSTIC.py
# PURPOSE: Verify position reading, open, close, hedge mode / positionSide work correctly
# NO trading logic — just open → close → open opposite → close — repeatedly
# Use VERY SMALL quantities only!

import time
import logging
from datetime import datetime

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
except ImportError:
    print("Cannot import DerivativesTradingUsdsFutures")
    print("Make sure: pip install binance-sdk-derivatives-trading-usds-futures")
    exit(1)

# ─── CONFIG ─────────────────────────────────────────────────────────────────
SYMBOL          = "XRPUSDT"           # change if testing other pair
TEST_QUANTITY   = 10               # VERY SMALL — adjust lower if needed
LEVERAGE        = 5                   # low leverage for safety
HEDGE_MODE      = True                # test both True and False
SLEEP_SECONDS   = 60                  # time between actions

# ─── Logging ────────────────────────────────────────────────────────────────
logging.basicConfig(
    filename='diagnostic_futures_bot.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

# ─── Client ─────────────────────────────────────────────────────────────────
client = DerivativesTradingUsdsFutures(
    config_rest_api={
        "api_key": "your_api_key_here",       # ← put real keys or import from config
        "api_secret": "your_api_secret_here",
        # For testnet (if SDK supports): add base_url or testnet param if available
    }
)

print(">>> DIAGNOSTIC MODE – VERY SMALL SIZES – WATCH CLOSELY <<<")
print(f"Symbol: {SYMBOL} | Hedge mode: {HEDGE_MODE} | Quantity per trade: {TEST_QUANTITY}")
logger.critical("DIAGNOSTIC BOT STARTED – SMALL SIZES – VERIFYING OPEN/CLOSE/HEDGE")

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol):
    """ Returns tuple (long_qty, short_qty) """
    try:
        positions = client.rest_api.position_risk(symbol=symbol)
        if not positions:
            return 0.0, 0.0

        long_qty = 0.0
        short_qty = 0.0

        for pos in positions:
            side = pos.get('positionSide', 'BOTH')
            amt = float(pos['positionAmt'])
            if side == 'LONG' or (side == 'BOTH' and amt > 0):
                long_qty = amt
            elif side == 'SHORT' or (side == 'BOTH' and amt < 0):
                short_qty = amt

        return long_qty, short_qty
    except Exception as e:
        logger.error(f"position query failed: {e}")
        print(f"position query failed: {e}")
        return 0.0, 0.0


def market_order(symbol, side: str, quantity: float, position_side: str = None):
    if abs(quantity) < 0.0001:
        print("Quantity too small – skipping")
        return None

    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": quantity
    }

    if HEDGE_MODE and position_side:
        params["positionSide"] = position_side.upper()

    try:
        order = client.rest_api.new_order(**params)
        msg = f"ORDER FILLED → {side.upper()} {quantity} {symbol}"
        if position_side:
            msg += f" ({position_side})"
        msg += f"  ID: {order.get('orderId')}"
        print(msg)
        logger.info(msg)
        return order
    except Exception as e:
        logger.error(f"order failed: {e}")
        print(f"order failed: {e}")
        return None


def close_side(symbol, side: str, qty: float):
    if abs(qty) < 0.0001:
        print(f"No {side} position to close")
        return None

    order_side = "SELL" if side == "LONG" else "BUY"
    qty_abs = abs(qty)
    logger.info(f"Closing {side} → {order_side} {qty_abs}")
    return market_order(symbol, order_side, qty_abs, position_side=side if HEDGE_MODE else None)


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_leverage(symbol=symbol, leverage=lev)
        print(f"Leverage set to {lev}x")
        logger.info(f"Leverage set to {lev}x")
    except Exception as e:
        if "2024" not in str(e):  # ignore "already set" error
            logger.warning(f"leverage warning: {e}")
            print(f"leverage warning: {e}")


# ─── Diagnostic loop states ─────────────────────────────────────────────────
STATE = "SHOW_STATUS"   # cycles: SHOW_STATUS → OPEN_LONG → CLOSE_LONG → OPEN_SHORT → CLOSE_SHORT → repeat

# ─── Main loop ──────────────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting DIAGNOSTIC bot → {SYMBOL}")
    logger.critical(f"DIAGNOSTIC START – {SYMBOL} – SMALL TEST SIZES")

    set_leverage(SYMBOL, LEVERAGE)

    cycle_count = 0

    while True:
        cycle_count += 1
        print(f"\n=== Cycle {cycle_count} – {datetime.utcnow():%Y-%m-%d %H:%M:%S UTC} ===")

        long_qty, short_qty = get_position(SYMBOL)

        print(f"Position:  LONG = {long_qty:.4f}   SHORT = {short_qty:.4f}")

        if STATE == "SHOW_STATUS":
            print("→ Just showing status...")
            STATE = "OPEN_LONG"

        elif STATE == "OPEN_LONG":
            if long_qty == 0 and short_qty == 0:
                print("→ Opening small LONG")
                market_order(SYMBOL, "BUY", TEST_QUANTITY, "LONG" if HEDGE_MODE else None)
            else:
                print("→ Already in position – skipping open long")
            STATE = "CLOSE_LONG"

        elif STATE == "CLOSE_LONG":
            if long_qty > 0.0001:
                print("→ Closing LONG")
                close_side(SYMBOL, "LONG", long_qty)
            else:
                print("→ No LONG to close")
            STATE = "OPEN_SHORT"

        elif STATE == "OPEN_SHORT":
            if long_qty == 0 and short_qty == 0:
                print("→ Opening small SHORT")
                market_order(SYMBOL, "SELL", TEST_QUANTITY, "SHORT" if HEDGE_MODE else None)
            else:
                print("→ Already in position – skipping open short")
            STATE = "CLOSE_SHORT"

        elif STATE == "CLOSE_SHORT":
            if short_qty < -0.0001:
                print("→ Closing SHORT")
                close_side(SYMBOL, "SHORT", short_qty)
            else:
                print("→ No SHORT to close")
            STATE = "OPEN_LONG"  # loop back

        print("───────────────────────────────────────")
        time.sleep(SLEEP_SECONDS)
