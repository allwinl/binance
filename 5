# bot.py
# Binance USDS-M Futures Telegram bot – auto check every 30 seconds
# Now with automatic reverse: if opposite signal appears → close current + open new direction

import asyncio
import logging
from datetime import datetime, timezone
import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Optional, Dict, Set
import pandas as pd
import math
from ta.trend import EMAIndicator   # pip install ta
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# ────────────────────────────────────────────────
# Load config
# ────────────────────────────────────────────────

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg = config.get("binance", {})
telegram_cfg = config.get("telegram", {})
trading_cfg = config.get("trading", {})

API_KEY        = binance_cfg.get("api_key")
API_SECRET     = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")

LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QUANTITY = trading_cfg.get("default_quantity", 0.001)
CHECK_INTERVAL_SECONDS = 30

if not API_KEY or not API_SECRET or not TELEGRAM_TOKEN:
    print("ERROR: Missing api_key, api_secret or telegram token")
    exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ────────────────────────────────────────────────
# State
# ────────────────────────────────────────────────

monitored_symbols: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}  # "LONG", "SHORT" or None

# ────────────────────────────────────────────────
# Binance helpers
# ────────────────────────────────────────────────

def signed_request(method: str, endpoint: str, params: Dict = None) -> Dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {data['code']}: {data.get('msg')}")
        return data
    except Exception as e:
        logger.error(f"Request failed: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None:
        params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed: {e}")
        return []

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            if s.get("contractType") == "PERPETUAL" and s.get("status") == "TRADING":
                return True
    return False

def get_klines(symbol: str, interval: str, limit: int = 100) -> list:
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines failed for {symbol} {interval}: {e}")
        return []

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> Dict:
    if qty <= 0:
        return {"error": "Invalid quantity"}

    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")

    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    logger.info(f"Order: {side.upper()} {qstr} {symbol} reduceOnly={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def close_all_positions():
    positions = signed_request("GET", "/fapi/v2/positionRisk")
    if not isinstance(positions, list):
        return []

    closed = []
    for pos in positions:
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) < 1e-8:
            continue

        sym = pos["symbol"]
        side = "SELL" if amt > 0 else "BUY"
        qty = abs(amt)
        resp = place_market_order(sym, side, qty, reduce_only=True)

        if resp.get("status") in ("FILLED", "NEW"):
            symbol_position_state[sym] = None

        closed.append((sym, resp))

    return closed

# ────────────────────────────────────────────────
# Auto-check loop – every 30 seconds
# ────────────────────────────────────────────────

async def auto_check_symbols(app: Application) -> None:
    while True:
        if monitored_symbols:
            logger.info(f"Auto-checking {len(monitored_symbols)} symbols...")
            for symbol in list(monitored_symbols):
                try:
                    klines_1m = get_klines(symbol, "1m", 50)
                    if not klines_1m or len(klines_1m) < 3:
                        logger.warning(f"Not enough 1m data for {symbol}")
                        continue

                    klines_1d = get_klines(symbol, "1d", 2)
                    if not klines_1d:
                        logger.warning(f"Failed to get 1d data for {symbol}")
                        continue

                    today_open = float(klines_1d[-1][1])
                    closes = [float(k[4]) for k in klines_1m]

                    df = pd.DataFrame({"close": closes})
                    ema_indicator = EMAIndicator(close=df["close"], window=3)
                    ema_series = ema_indicator.ema_indicator()
                    ema_value = ema_series.iloc[-1]

                    current_side = symbol_position_state.get(symbol, None)

                    logger.info(
                        f"[{symbol}] 1d open: {today_open:.4f} | EMA-3: {ema_value:.4f} | current: {current_side or 'None'}"
                    )

                    should_long  = ema_value > today_open
                    should_short = ema_value < today_open

                    # Case 1: No position → normal open
                    if current_side is None:
                        if should_long:
                            logger.info(f"→ {symbol} open LONG")
                            resp = place_market_order(symbol, "BUY", DEFAULT_QUANTITY)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"
                        elif should_short:
                            logger.info(f"→ {symbol} open SHORT")
                            resp = place_market_order(symbol, "SELL", DEFAULT_QUANTITY)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"
                        else:
                            logger.info(f"→ {symbol} neutral – no action")

                    # Case 2: Already LONG → check if should reverse to SHORT
                    elif current_side == "LONG":
                        if should_short:
                            logger.info(f"→ {symbol} reverse: close LONG + open SHORT")
                            # Close LONG
                            close_resp = place_market_order(symbol, "SELL", DEFAULT_QUANTITY, reduce_only=True)
                            if close_resp.get("status") in ("NEW", "FILLED"):
                                # Open SHORT
                                open_resp = place_market_order(symbol, "SELL", DEFAULT_QUANTITY)
                                if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                    symbol_position_state[symbol] = "SHORT"
                        else:
                            logger.info(f"→ {symbol} still LONG signal – holding")

                    # Case 3: Already SHORT → check if should reverse to LONG
                    elif current_side == "SHORT":
                        if should_long:
                            logger.info(f"→ {symbol} reverse: close SHORT + open LONG")
                            # Close SHORT
                            close_resp = place_market_order(symbol, "BUY", DEFAULT_QUANTITY, reduce_only=True)
                            if close_resp.get("status") in ("NEW", "FILLED"):
                                # Open LONG
                                open_resp = place_market_order(symbol, "BUY", DEFAULT_QUANTITY)
                                if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                    symbol_position_state[symbol] = "LONG"
                        else:
                            logger.info(f"→ {symbol} still SHORT signal – holding")

                except Exception as e:
                    logger.error(f"Error checking {symbol}: {e}")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ────────────────────────────────────────────────
# Telegram handlers (same as before, only showing changed parts for brevity)
# ────────────────────────────────────────────────

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Futures EMA-3 bot – auto-reverse enabled\n\n"
        "• Every 30s checks monitored symbols\n"
        "• If opposite signal → auto close current + open new direction\n"
        "• Skips if same direction or neutral\n\n"
        "Commands:\n"
        "/add SYMBOL\n"
        "/rem SYMBOL\n"
        "/rem or /reset   (close all + clear)\n"
        "/test SYMBOL     (manual full cycle)\n"
    )

# ... cmd_add, cmd_rem, cmd_test remain almost same (omitted for brevity) ...

async def handle_symbol_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text.strip().upper()
    if text.startswith('/') or len(text) < 4 or not text.endswith("USDT"):
        return

    symbol = text

    if symbol not in monitored_symbols:
        await update.message.reply_text(f"{symbol} not monitored. Use /add first.")
        return

    current_side = symbol_position_state.get(symbol, None)
    if current_side is not None:
        await update.message.reply_text(
            f"Manual check skipped: {symbol} already {current_side}\n"
            "(auto-reverse only happens in background loop)"
        )
        return

    # Manual check – same as auto but send to user
    await update.message.reply_text(f"Manual check: {symbol}")

    klines_1m = get_klines(symbol, "1m", 50)
    if not klines_1m or len(klines_1m) < 3:
        await update.message.reply_text("Not enough 1m data")
        return

    klines_1d = get_klines(symbol, "1d", 2)
    if not klines_1d:
        await update.message.reply_text("Failed to get 1d data")
        return

    today_open = float(klines_1d[-1][1])
    closes = [float(k[4]) for k in klines_1m]

    df = pd.DataFrame({"close": closes})
    ema_indicator = EMAIndicator(close=df["close"], window=3)
    ema_value = ema_indicator.ema_indicator().iloc[-1]

    msg = (
        f"**Manual check {symbol}**\n"
        f"1d open: {today_open:.4f}\n"
        f"EMA-3 (1m): {ema_value:.4f}\n"
    )

    if ema_value > today_open:
        msg += "→ opening LONG"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "BUY", DEFAULT_QUANTITY)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "LONG"
    elif ema_value < today_open:
        msg += "→ opening SHORT"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "SELL", DEFAULT_QUANTITY)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "SHORT"
    else:
        msg += "→ no action"
        await update.message.reply_text(msg)

async def on_startup(app: Application) -> None:
    asyncio.create_task(auto_check_symbols(app))
    logger.info(f"Auto-check with reverse started – interval {CHECK_INTERVAL_SECONDS}s")

def main() -> None:
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("add", cmd_add))
    app.add_handler(CommandHandler("rem", cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))
    app.add_handler(CommandHandler("test", cmd_test))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_symbol_message))

    app.post_init = on_startup

    print("Bot starting...")
    print("Monitored:", monitored_symbols)
    print("States:", symbol_position_state)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
