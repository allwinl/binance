# bot.py
# Binance USDS-M Futures – ORDER PLACEMENT TEST (LONG + SHORT separately)
# Tests: open LONG → close LONG → open SHORT → close SHORT
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION

import time
import logging
from datetime import datetime, timezone

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_sdk_derivatives_trading_usds_futures.rest_api.models import NewOrderSideEnum
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # needs API_KEY, API_SECRET

# ─── Config ─────────────────────────────────────────────────────────────────
TEST_MODE       = True
SYMBOL          = "XRPUSDT"
TEST_QUANTITY   = 2           # very small – lower to 5 or 2 if minQty error
LEVERAGE        = 3
SLEEP_SECONDS   = 15             # a bit longer so you can see clearly

# ─── Logging ────────────────────────────────────────────────────────────────
logging.basicConfig(
    filename='order_test_long_short.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

print(">>> LIVE MODE – REAL MONEY – EXTREME CAUTION <<<")
print(">>> LONG + SHORT SEPARATE TEST MODE ACTIVE <<<")
logger.critical("BOT STARTED – LONG/SHORT OPEN+CLOSE TEST – REAL MONEY AT RISK")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol):
    try:
        positions = client.rest_api.position_information_v3(symbol=symbol)
    except Exception:
        try:
            positions = client.rest_api.position_information_v2(symbol=symbol)
        except Exception as e:
            logger.error(f"position query failed: {e}")
            return 0.0

    qty = 0.0
    if isinstance(positions, list):
        for pos in positions:
            if pos.get('symbol') == symbol:
                qty = float(pos.get('positionAmt', '0'))
                break
    return qty


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        logger.info(f"Leverage set → {lev}x")
        print(f"Leverage set → {lev}x")
    except Exception as e:
        logger.warning(f"Leverage set failed (may already be set): {e}")


def market_order(symbol, side_enum, quantity: float):
    if abs(quantity) < 0.1:
        print("Quantity too small – skipping")
        return None

    qty = round(abs(quantity), 0)  # XRPUSDT usually integer

    params = {
        "symbol": symbol,
        "side": side_enum.value,
        "type": "MARKET",
        "quantity": qty,
    }

    try:
        response = client.rest_api.new_order(**params)

        data = getattr(response, 'data', None) or response
        logger.info(f"new_order response: {data}")

        msg = f"ORDER SUCCESS → {side_enum.name} {qty} {symbol}"
        if hasattr(data, 'orderId') or (isinstance(data, dict) and 'orderId' in data):
            order_id = data.orderId if hasattr(data, 'orderId') else data['orderId']
            msg += f"  ID: {order_id}"
        print(msg)
        return response
    except Exception as e:
        logger.error(f"order failed: {e}")
        print(f"ORDER FAILED: {e}")
        return None


def open_long():
    print("→ Opening LONG")
    return market_order(SYMBOL, NewOrderSideEnum["BUY"], TEST_QUANTITY)


def close_long(current_qty):
    if current_qty <= 0:
        print("No LONG position to close")
        return None
    print("→ Closing LONG")
    return market_order(SYMBOL, NewOrderSideEnum["SELL"], current_qty)


def open_short():
    print("→ Opening SHORT")
    return market_order(SYMBOL, NewOrderSideEnum["SELL"], TEST_QUANTITY)


def close_short(current_qty):
    if current_qty >= 0:
        print("No SHORT position to close")
        return None
    print("→ Closing SHORT (buy back)")
    return market_order(SYMBOL, NewOrderSideEnum["BUY"], abs(current_qty))


# ─── Test sequence: LONG open → close → SHORT open → close ──────────────────

def run_test_cycle():
    position_qty = get_position(SYMBOL)
    print(f"Current position: {position_qty:+.2f}")

    # Phase 1: Open LONG if flat
    if position_qty == 0:
        open_long()
        time.sleep(SLEEP_SECONDS)
        return

    # Phase 2: Close LONG if open
    if position_qty > 0:
        close_long(position_qty)
        time.sleep(SLEEP_SECONDS)
        return

    # Phase 3: Open SHORT if flat again
    if position_qty == 0:
        open_short()
        time.sleep(SLEEP_SECONDS)
        return

    # Phase 4: Close SHORT if open
    if position_qty < 0:
        close_short(position_qty)
        time.sleep(SLEEP_SECONDS)
        return

    print("Unexpected position state – skipping this cycle")


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting LONG → close → SHORT → close TEST → {SYMBOL}  LEVERAGE {LEVERAGE}")
    logger.critical(f"LONG/SHORT TEST STARTED – {SYMBOL} – REAL MONEY")

    set_leverage(SYMBOL, LEVERAGE)

    cycle = 0

    while TEST_MODE:
        cycle += 1
        now_utc = datetime.now(timezone.utc)
        print(f"\n=== Test cycle {cycle} at {now_utc.strftime('%Y-%m-%d %H:%M:%S UTC')} ===")
        try:
            run_test_cycle()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            logger.info("Stopped by user")
            break
        except Exception as e:
            logger.critical(f"MAIN LOOP ERROR: {e}", exc_info=True)
            print(f"CRITICAL ERROR: {e}")
            time.sleep(30)

        time.sleep(SLEEP_SECONDS)

    print("Test mode stopped.")
