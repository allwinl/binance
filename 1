# bot.py
# Binance USDS-M Futures bot – EMA(21) on 15m vs daily open – IMPROVED LIVE VERSION
# Uses python-binance for clean klines fetching + official SDK for trading
# REAL PRODUCTION – EXTREME CAUTION – Jan 2026

import time
import logging
from datetime import datetime
import pandas as pd

# ─── Official SDK (for trading / account) ───────────────────────────────────
try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing official SDK packages")
    print("pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

# ─── python-binance for clean klines ────────────────────────────────────────
try:
    from binance.client import Client as BinanceClient
except ImportError:
    print("Missing python-binance")
    print("pip install python-binance")
    exit(1)

import config  # your config.py with API_KEY, API_SECRET, SYMBOL="BTCUSDT", INTERVAL="15m", etc.

# ─── Logging ────────────────────────────────────────────────────────────────
logging.basicConfig(
    filename='live_futures_bot.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

# ─── Clients ────────────────────────────────────────────────────────────────
print(">>> LIVE MODE – REAL MONEY – EXTREME CAUTION <<<")
logger.critical("BOT STARTED IN LIVE MODE – REAL MONEY AT RISK")

# Official SDK client (trading)
configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
trading_client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# python-binance client (market data – no secret needed for public endpoints)
market_client = BinanceClient()  # public only – add api_key/api_secret if using private later

# ─── Configurable constants ─────────────────────────────────────────────────
STOP_LOSS_PCT = 0.035
MIN_NOTIONAL_USDT = 5.0
QTY_ROUND_DECIMALS = 3
PRICE_ROUND_DECIMALS = 1

# ─── Market Data Helpers (using python-binance – clean & reliable) ──────────

def get_historical_data(symbol, interval, limit=400):
    """Like your reference: fetch OHLCV and return DataFrame"""
    try:
        ohlcv = market_client.futures_klines(symbol=symbol, interval=interval, limit=limit)
        df = pd.DataFrame(ohlcv, columns=[
            'open_time', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_volume', 'trades', 'taker_base', 'taker_quote', 'ignore'
        ])
        df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
        numeric_cols = ['open', 'high', 'low', 'close', 'volume', 'quote_volume']
        df[numeric_cols] = df[numeric_cols].apply(pd.to_numeric, errors='coerce')
        df.set_index('open_time', inplace=True)
        return df.dropna(subset=['close'])
    except Exception as e:
        logger.error(f"fetch_ohlcv failed: {e}")
        print(f"klines ERROR: {e}")
        return None


def get_daily_open(symbol):
    """Get today's open or previous close as fallback"""
    try:
        df = get_historical_data(symbol, '1d', limit=3)
        if df is None or len(df) < 1:
            return None

        now = pd.Timestamp.utcnow()
        today_midnight = now.floor('D')

        if df.index[ -1 ] >= today_midnight:
            # Current day candle exists → use its open
            return float(df['open'].iloc[-1])
        else:
            # Use previous day close
            return float(df['close'].iloc[-1])

    except Exception as e:
        logger.error(f"daily open failed: {e}")
        return None


# ─── Trading Helpers (using official SDK) ───────────────────────────────────

def get_position(symbol):
    try:
        positions = trading_client.rest_api.position_information_v3(symbol=symbol)
    except Exception:
        try:
            positions = trading_client.rest_api.position_information_v2(symbol=symbol)
        except Exception as e:
            logger.error(f"position query failed: {e}")
            return 0.0, 0.0

    long_qty = 0.0
    short_qty = 0.0

    if isinstance(positions, list):
        for pos in positions:
            if pos.get('symbol') == symbol:
                amt = float(pos.get('positionAmt', '0'))
                side = pos.get('positionSide', 'BOTH')
                if side in ('LONG', 'BOTH') and amt > 0:
                    long_qty = amt
                elif side in ('SHORT', 'BOTH') and amt < 0:
                    short_qty = amt

    return long_qty, short_qty


def is_long(qty): return qty > 1e-4
def is_short(qty): return qty < -1e-4


def get_usdt_balance():
    try:
        account = trading_client.rest_api.account_information_v3()
        for asset in account.get('assets', []):
            if asset.get('asset') == 'USDT':
                return float(asset.get('availableBalance', 0.0))
        return 0.0
    except Exception as e:
        logger.error(f"balance failed: {e}")
        return 0.0


def set_leverage(symbol, lev):
    try:
        trading_client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        logger.info(f"Leverage set to {lev}x")
    except Exception as e:
        logger.warning(f"Leverage set failed (maybe already set): {e}")


def market_order(symbol, side: str, quantity: float, position_side: str = None):
    if abs(quantity) < 0.0005:
        return None
    qty = round(quantity, QTY_ROUND_DECIMALS)
    if qty <= 0:
        return None

    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qty,
        "newOrderRespType": "RESULT"
    }
    if config.HEDGE_MODE and position_side:
        params["positionSide"] = position_side.upper()

    try:
        order = trading_client.rest_api.new_order(**params)
        msg = f"ORDER FILLED → {side.upper()} {qty:.3f} {symbol}"
        if position_side:
            msg += f" ({position_side})"
        msg += f" ID: {order.get('orderId')}"
        print(msg)
        logger.info(msg)
        return order
    except Exception as e:
        logger.error(f"order failed: {e}")
        print(f"ORDER FAILED: {e}")
        return None


def place_protective_stop(symbol, side: str, qty: float, entry_price: float):
    if side.upper() == "LONG":
        stop_price = round(entry_price * (1 - STOP_LOSS_PCT), PRICE_ROUND_DECIMALS)
        stop_side = "SELL"
        pos_side = "LONG"
    else:
        stop_price = round(entry_price * (1 + STOP_LOSS_PCT), PRICE_ROUND_DECIMALS)
        stop_side = "BUY"
        pos_side = "SHORT"

    params = {
        "symbol": symbol,
        "side": stop_side,
        "type": "STOP_MARKET",
        "quantity": round(qty, QTY_ROUND_DECIMALS),
        "stopPrice": stop_price,
        "closePosition": True,
    }
    if config.HEDGE_MODE:
        params["positionSide"] = pos_side

    try:
        order = trading_client.rest_api.new_order(**params)
        logger.info(f"STOP placed @ {stop_price} ({side}) ID: {order.get('orderId')}")
    except Exception as e:
        logger.critical(f"STOP PLACEMENT FAILED – DANGER: {e}")


def close_side(symbol, side: str, qty: float):
    if abs(qty) < 0.0005:
        return None
    order_side = "SELL" if side == "LONG" else "BUY"
    qty_abs = abs(qty)
    logger.info(f"Closing {side} → {order_side} {qty_abs:.3f}")
    return market_order(symbol, order_side, qty_abs, side if config.HEDGE_MODE else None)


# ─── Strategy ───────────────────────────────────────────────────────────────

def should_open_long(price: float, ema: float, daily_open: float) -> bool:
    return price > ema


def should_close_long(price: float, ema: float) -> bool:
    return price < ema * 0.988


def should_open_short(price: float, ema: float, daily_open: float) -> bool:
    return price < ema and price <= daily_open * (1 - config.DAILY_OPEN_TOLERANCE)


def should_close_short(price: float, ema: float) -> bool:
    return price > ema * 1.012


def calculate_quantity(usdt: float, price: float) -> float:
    if price <= 0:
        return 0.0
    risk_usdt = usdt * config.POSITION_PCT
    notional = risk_usdt * config.LEVERAGE
    if notional < MIN_NOTIONAL_USDT:
        logger.warning(f"Notional too small {notional:.2f}")
        return 0.0
    return notional / price


def run_once():
    df = get_historical_data(config.SYMBOL, config.INTERVAL, limit=config.EMA_PERIOD * 4)
    if df is None or len(df) < config.EMA_PERIOD + 10:
        logger.warning("Not enough candles")
        return

    df['ema'] = df['close'].ewm(span=config.EMA_PERIOD, adjust=False).mean()

    price = float(df['close'].iloc[-1])
    ema   = float(df['ema'].iloc[-1])
    daily_open = get_daily_open(config.SYMBOL)

    if daily_open is None:
        logger.warning("No daily open")
        return

    ts = datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
    print(f"{ts} | price {price:,.2f} | EMA{config.EMA_PERIOD} ({config.INTERVAL}) {ema:,.2f} | daily open {daily_open:,.2f}")
    logger.info(f"price {price:,.2f} | ema {ema:,.2f} | open {daily_open:,.2f}")

    long_qty, short_qty = get_position(config.SYMBOL)
    usdt = get_usdt_balance()

    if usdt < config.MIN_SAFE_BALANCE and (abs(long_qty) > 1e-4 or abs(short_qty) > 1e-4):
        logger.critical(f"EMERGENCY CLOSE – low balance {usdt:.2f}")
        if long_qty: close_side(config.SYMBOL, "LONG", long_qty)
        if short_qty: close_side(config.SYMBOL, "SHORT", short_qty)
        return

    # Close
    if is_long(long_qty) and should_close_long(price, ema):
        logger.info("Closing LONG")
        close_side(config.SYMBOL, "LONG", long_qty)

    if is_short(short_qty) and should_close_short(price, ema):
        logger.info("Closing SHORT")
        close_side(config.SYMBOL, "SHORT", short_qty)

    # Open
    if not is_long(long_qty) and should_open_long(price, ema, daily_open):
        qty = calculate_quantity(usdt, price)
        if qty >= 0.001:
            logger.info(f"LONG signal → qty ≈ {qty:.3f}")
            order = market_order(config.SYMBOL, "BUY", qty, "LONG" if config.HEDGE_MODE else None)
            if order and 'avgPrice' in order and float(order['avgPrice']) > 0:
                place_protective_stop(config.SYMBOL, "LONG", qty, float(order['avgPrice']))

    if not is_short(short_qty) and should_open_short(price, ema, daily_open):
        qty = calculate_quantity(usdt, price)
        if qty >= 0.001:
            logger.info(f"SHORT signal → qty ≈ {qty:.3f}")
            order = market_order(config.SYMBOL, "SELL", qty, "SHORT" if config.HEDGE_MODE else None)
            if order and 'avgPrice' in order and float(order['avgPrice']) > 0:
                place_protective_stop(config.SYMBOL, "SHORT", qty, float(order['avgPrice']))


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting LIVE bot → {config.SYMBOL} {config.INTERVAL} EMA({config.EMA_PERIOD})")
    logger.critical(f"LIVE BOT STARTED – {config.SYMBOL} – REAL MONEY")

    set_leverage(config.SYMBOL, config.LEVERAGE)

    while True:
        try:
            run_once()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            logger.info("Stopped by user")
            break
        except Exception as e:
            logger.critical(f"MAIN LOOP ERROR: {e}", exc_info=True)
            print(f"CRITICAL: {e}")
            time.sleep(30)

        time.sleep(config.SLEEP_SECONDS)
