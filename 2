# bot.py
# Binance USDS-M Futures – LONG/SHORT test + BALANCE + MARGIN DIAGNOSTICS
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION

import time
import logging
from datetime import datetime, timezone

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_sdk_derivatives_trading_usds_futures.rest_api.models import NewOrderSideEnum
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # needs API_KEY, API_SECRET

# ─── Config ─────────────────────────────────────────────────────────────────
TEST_MODE           = True
SYMBOL              = "XRPUSDT"
TEST_QUANTITY       = 5.0
LEVERAGE            = 5
SLEEP_SECONDS       = 20
ORDER_CONFIRM_DELAY = 10.0

logging.basicConfig(
    filename='balance_margin_debug.log',
    level=logging.DEBUG,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

print(">>> LIVE TRADING CODE – REAL MONEY – EXTREME CAUTION <<<")
print(">>> Sequence: LONG → close → SHORT → close + balance/margin debug <<<")
logger.critical("BOT STARTED – BALANCE & MARGIN DEBUG – REAL MONEY")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Account Status ─────────────────────────────────────────────────────────

def print_account_status():
    try:
        response = client.rest_api.account_information_v3()
        
        # response is AccountInformationV3Response object
        
        print("\nDEBUG: Account response type →", type(response))
        print("DEBUG: Has 'assets' attribute →", hasattr(response, 'assets'))
        
        usdt_info = None
        assets_list = getattr(response, 'assets', [])
        print("DEBUG: Number of assets →", len(assets_list))
        
        for asset in assets_list:
            asset_name = getattr(asset, 'asset', '')
            if asset_name == 'USDT':
                usdt_info = asset
                break

        if usdt_info:
            print("\nFutures USDT Status:")
            print(f"  Wallet Balance:     {getattr(usdt_info, 'walletBalance', 'N/A')}")
            print(f"  Available Balance:  {getattr(usdt_info, 'availableBalance', 'N/A')}")
            print(f"  Unrealized PnL:     {getattr(usdt_info, 'unrealizedProfit', 'N/A')}")
            print(f"  Margin Balance:     {getattr(usdt_info, 'marginBalance', 'N/A')}")
            # Extra fields from official docs
            print(f"  Initial Margin:     {getattr(usdt_info, 'initialMargin', 'N/A')}")
            print(f"  Maint. Margin:      {getattr(usdt_info, 'maintMargin', 'N/A')}")
        else:
            print("No USDT asset found in assets list. Available assets:")
            for a in assets_list:
                print(f"  - {getattr(a, 'asset', 'UNKNOWN')}")

        # Top-level fields
        print(f"\nMargin Ratio:             {getattr(response, 'marginRatio', 'N/A')}")
        print(f"Total Maint. Margin:      {getattr(response, 'totalMaintMargin', 'N/A')}")
        print(f"Total Wallet Balance:     {getattr(response, 'totalWalletBalance', 'N/A')}")
        print(f"Total Unrealized PnL:     {getattr(response, 'totalUnrealizedProfit', 'N/A')}")
        print(f"Total Margin Balance:     {getattr(response, 'totalMarginBalance', 'N/A')}")
        print(f"Available Balance (global): {getattr(response, 'availableBalance', 'N/A')}")

    except Exception as e:
        print(f"Account info failed: {str(e)}")
        logger.error(f"Account info failed: {str(e)}", exc_info=True)


# ─── Position query ─────────────────────────────────────────────────────────

def get_position(symbol):
    qty = 0.0
    raw_data = None
    used_endpoint = "none"

    for endpoint_name in ['position_information_v3', 'position_information_v2']:
        try:
            method = getattr(client.rest_api, endpoint_name)
            resp = method(symbol=symbol)

            data = resp.data() if hasattr(resp, 'data') and callable(getattr(resp, 'data')) else resp
            raw_data = data
            used_endpoint = endpoint_name
            logger.debug(f"{endpoint_name} raw data: {data}")

            if isinstance(data, list):
                for pos in data:
                    if pos.get('symbol') == symbol:
                        amt_str = pos.get('positionAmt', '0')
                        qty = float(amt_str)
                        logger.info(f"{endpoint_name} → positionAmt = {amt_str}")
                        break

            if qty != 0.0:
                break

        except Exception as e:
            logger.error(f"{endpoint_name} failed: {e}")

    print(f"Detected position: {qty:+.2f} (from {used_endpoint})")
    if raw_data is not None:
        print(f"Raw positions data: {raw_data}")

    return qty


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        logger.info(f"Leverage set → {lev}x")
        print(f"Leverage set → {lev}x")
    except Exception as e:
        logger.warning(f"Leverage set failed (maybe already set?): {e}")


def market_order(symbol, side_enum, quantity: float):
    if abs(quantity) < 0.1:
        print("Quantity too small – skipping")
        return None

    qty = round(abs(quantity), 0)

    print_account_status()

    params = {
        "symbol": symbol,
        "side": side_enum.value,
        "type": "MARKET",
        "quantity": qty,
    }

    try:
        response = client.rest_api.new_order(**params)

        data = response.data() if hasattr(response, 'data') and callable(getattr(response, 'data')) else response
        logger.info(f"new_order response: {data}")

        msg = f"ORDER SUCCESS → {side_enum.name} {qty} {symbol}"
        order_id = data.get('orderId') if isinstance(data, dict) else getattr(data, 'orderId', None)
        if order_id:
            msg += f"  ID: {order_id}"
        print(msg)

        print(f"Order sent → waiting {ORDER_CONFIRM_DELAY}s for position update...")
        time.sleep(ORDER_CONFIRM_DELAY)

        print("\nAfter order:")
        print_account_status()

        return response

    except Exception as e:
        logger.error(f"order failed: {e}")
        print(f"ORDER FAILED: {e}")
        return None


# ─── Actions ────────────────────────────────────────────────────────────────

def open_long():
    print("→ Opening LONG")
    return market_order(SYMBOL, NewOrderSideEnum["BUY"], TEST_QUANTITY)


def close_long(current_qty):
    if current_qty <= 0:
        print("No LONG position to close")
        return None
    print(f"→ Closing LONG ({current_qty:.1f})")
    return market_order(SYMBOL, NewOrderSideEnum["SELL"], current_qty)


def open_short():
    print("→ Opening SHORT")
    return market_order(SYMBOL, NewOrderSideEnum["SELL"], TEST_QUANTITY)


def close_short(current_qty):
    if current_qty >= 0:
        print("No SHORT position to close")
        return None
    print(f"→ Closing SHORT ({abs(current_qty):.1f})")
    return market_order(SYMBOL, NewOrderSideEnum["BUY"], abs(current_qty))


# ─── State machine ──────────────────────────────────────────────────────────

last_phase = "start"

def run_test_cycle():
    global last_phase

    position_qty = get_position(SYMBOL)

    if position_qty == 0:
        if last_phase in ["start", "closed_long", "closed_short"]:
            print("Flat → opening LONG")
            resp = open_long()
            if resp:
                last_phase = "opened_long"
        elif last_phase == "closed_long":
            print("Just closed LONG → opening SHORT")
            resp = open_short()
            if resp:
                last_phase = "opened_short"

    elif position_qty > 0:
        if last_phase == "opened_long":
            print("LONG opened → closing it")
            resp = close_long(position_qty)
            if resp:
                last_phase = "closed_long"
        else:
            print("LONG detected unexpectedly → closing")
            resp = close_long(position_qty)
            if resp:
                last_phase = "closed_long"

    elif position_qty < 0:
        if last_phase == "opened_short":
            print("SHORT opened → closing it")
            resp = close_short(position_qty)
            if resp:
                last_phase = "closed_short"
        else:
            print("SHORT detected unexpectedly → closing")
            resp = close_short(position_qty)
            if resp:
                last_phase = "closed_short"


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting cycle: LONG → close → SHORT → close  |  {SYMBOL} @ {LEVERAGE}x")
    logger.critical(f"TEST STARTED – {SYMBOL} – REAL MONEY – BALANCE/MARGIN DEBUG")

    set_leverage(SYMBOL, LEVERAGE)

    print("\nInitial account status:")
    print_account_status()

    cycle = 0

    while TEST_MODE:
        cycle += 1
        now_utc = datetime.now(timezone.utc)
        print(f"\n=== Test cycle {cycle} at {now_utc.strftime('%Y-%m-%d %H:%M:%S UTC')} ===")
        try:
            run_test_cycle()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            logger.info("Stopped by user")
            break
        except Exception as e:
            logger.critical(f"MAIN LOOP ERROR: {e}", exc_info=True)
            print(f"CRITICAL ERROR: {e}")
            time.sleep(30)

        time.sleep(SLEEP_SECONDS)

    print("Test mode stopped.")
