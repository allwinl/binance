import ccxt
import pandas as pd
import asyncio
import nest_asyncio
import requests
from datetime import datetime, timezone

interval = '1m'  # ← changed to 1-minute candles

# Initialize binance client (public data only is enough)
binance = ccxt.binance({
    'enableRateLimit': True,
    # 'apiKey': '...',     # not needed for OHLCV
    # 'secret': '...',
})

# Dictionary to prevent sending duplicate signals at same price
last_signals = {}

# Fetch USDT perpetual futures symbols dynamically
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()

    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT'
        and s['contractType'] == 'PERPETUAL'
        and s['status'] == 'TRADING'
    ]
    print(f"Loaded {len(SELECTED_SYMBOLS)} USDT perpetual symbols")
except requests.exceptions.RequestException as e:
    print(f"Error fetching futures symbols: {e}")
    SELECTED_SYMBOLS = []

# Get recent candlestick data
def get_historical_data(symbol, interval, limit=25):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Get reference price from previous daily close
def get_day_reference_price(symbol):
    day_ohlcv = binance.fetch_ohlcv(symbol, '1d', limit=3)
    df_day = pd.DataFrame(day_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df_day['timestamp'] = pd.to_datetime(df_day['timestamp'], unit='ms')
    df_day.set_index('timestamp', inplace=True)
    # Using previous daily close as reference level
    return df_day['close'].iloc[-2]

# SMA calculation
def calculate_sma(df, period):
    return df['close'].rolling(window=period).mean()

# Check crossover / crossunder vs reference price
def check_sma_crossover_vs_reference(df, reference_price, short_period=3):
    df['sma_short'] = calculate_sma(df, short_period)
    cross_over  = df['sma_short'].iloc[-2] <= reference_price and df['sma_short'].iloc[-1] > reference_price
    cross_under = df['sma_short'].iloc[-2] >= reference_price and df['sma_short'].iloc[-1] < reference_price
    return cross_over, cross_under

# Send signal to Binance webhook
def send_binance_signal(symbol, side, close_price):
    key = f"{symbol}_{side}"
    # Avoid resending at exactly same price
    if last_signals.get(key) == close_price:
        return

    payload = {
        "symbol": symbol,
        "side": side.upper(),               # BUY or SELL
        "positionSide": "BOTH",
        "investmentType": "notional_value",
        "amount": "10",
        "price": str(close_price),
        "reduceOnly": False,
        "positionMode": "one_way_mode",
        "signalId": "c8c565bf-ea6b-4a76-93d8-76fd0d6900d0",
        "uid": "30a07ee161389902638c30aeed695061035924de7c970f76b14ba6088aaaa7b8"
    }

    try:
        response = requests.post(
            "https://cb.binanceapi.com/webhook/handle-signal",
            json=payload,
            timeout=10
        )

        ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        if response.status_code in (200, 201):
            print(f"[{ts}] OK → {symbol} {side} @ {close_price:,.2f}")
            last_signals[key] = close_price
        else:
            print(f"[{ts}] FAIL {symbol} {side} → {response.status_code} {response.text[:180]}")

    except requests.RequestException as e:
        ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        print(f"[{ts}] Request error {symbol} {side}: {e}")

# ────────────────────────────────────────────────
async def main():
    if not SELECTED_SYMBOLS:
        print("No symbols loaded. Exiting.")
        return

    print("Starting 1m SMA(3) crossover bot — checking every ~60 seconds")

    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                df = get_historical_data(symbol, interval, limit=40)
                if len(df) < 10:
                    continue

                ref_price = get_day_reference_price(symbol)
                cross_over, cross_under = check_sma_crossover_vs_reference(df, ref_price)

                close_price = df['close'].iloc[-1]

                if cross_over:
                    send_binance_signal(symbol, "buy", close_price)
                elif cross_under:
                    send_binance_signal(symbol, "sell", close_price)

            except Exception as e:
                print(f"Error {symbol}: {type(e).__name__} - {e}")

        await asyncio.sleep(60)  # ← changed to 60 seconds

# Allow nested event loops (Jupyter, IPython, etc.)
nest_asyncio.apply()

if __name__ == "__main__":
    asyncio.run(main())
