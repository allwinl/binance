# bot.py
# Binance USDS-M Futures – single file – REST API only – mainnet
# No user input prompts – orders are sent immediately

import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
import math
import sys

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found in current directory")
    sys.exit(1)

cfg = config.get("binance", {})
trade_cfg = config.get("trading", {})

API_KEY     = cfg.get("api_key")
API_SECRET  = cfg.get("api_secret")
SYMBOL      = trade_cfg.get("symbol", "XRPUSDT")
LEVERAGE    = trade_cfg.get("leverage", 5)
MARGIN_TYPE = trade_cfg.get("margin_type", "ISOLATED").upper()
DEFAULT_QTY = trade_cfg.get("default_quantity", 50.0)

if not API_KEY or not API_SECRET:
    print("ERROR: api_key and/or api_secret missing in config.yaml")
    sys.exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

symbol_prec = {"qty": 3, "price": 2}
symbol_info = {}

def signed_req(method: str, path: str, params: dict = None) -> dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{path}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError(f"Unsupported method: {method}")

        r.raise_for_status()
        data = r.json()

        # Show rate limits if present
        for k in r.headers:
            if "X-MBX-USED-WEIGHT" in k or "X-MBX-ORDER-COUNT" in k:
                print(f"   {k}: {r.headers[k]}")

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            print(f"API ERROR {data['code']}: {data.get('msg', 'no message')}")
        else:
            print("Response:", data)

        return data

    except Exception as e:
        print(f"Request failed: {str(e)}")
        return {"error": str(e)}

def load_symbol():
    global symbol_prec, symbol_info
    try:
        data = requests.get(f"{BASE_URL}/fapi/v1/exchangeInfo", timeout=8).json()
        for sym in data.get("symbols", []):
            if sym["symbol"] == SYMBOL:
                for f in sym.get("filters", []):
                    if f["filterType"] == "LOT_SIZE":
                        step = float(f["stepSize"])
                        symbol_prec["qty"] = -int(round(math.log10(step)))
                        symbol_info["minQty"] = float(f["minQty"])
                        symbol_info["stepSize"] = step
                    if f["filterType"] == "PRICE_FILTER":
                        symbol_prec["price"] = -int(round(math.log10(float(f["tickSize"]))))
                    if f["filterType"] == "MIN_NOTIONAL":
                        symbol_info["minNotional"] = float(f.get("notional", 5.0))
                print(f"Symbol {SYMBOL}: qty prec={symbol_prec['qty']}, price prec={symbol_prec['price']}")
                print(f"  minQty={symbol_info.get('minQty')}, stepSize={symbol_info.get('stepSize')}")
                print(f"  minNotional ≈ {symbol_info.get('minNotional', '?')} USDT")
                return
        print("Symbol not found in exchangeInfo")
    except Exception as e:
        print(f"exchangeInfo failed: {e}")

def fmt_qty(q: float) -> str:
    p = symbol_prec["qty"]
    s = f"{q:.{p}f}"
    return s.rstrip("0").rstrip(".") if "." in s else s

def place_market(side: str, qty: float = None, reduce_only: bool = False):
    qty = qty or DEFAULT_QTY
    qstr = fmt_qty(qty)

    params = {
        "symbol": SYMBOL,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    print(f"\n>>> PLACING {side.upper()} {qstr} {SYMBOL}  reduceOnly={reduce_only}")
    return signed_req("POST", "/fapi/v1/order", params)

def get_balance():
    data = signed_req("GET", "/fapi/v2/account")
    if "assets" in data:
        for a in data["assets"]:
            if a["asset"] == "USDT":
                return float(a.get("availableForWithdrawal", 0))
    return 0.0

def get_pos():
    data = signed_req("GET", "/fapi/v2/positionRisk", {"symbol": SYMBOL})
    if isinstance(data, list) and data:
        p = data[0]
        amt = float(p.get("positionAmt", "0"))
        if abs(amt) > 1e-8:
            side = "LONG" if amt > 0 else "SHORT"
            print(f"Position: {side} | {amt:.{symbol_prec['qty']}f} | "
                  f"entry {float(p['entryPrice']):.4f} | PnL {float(p['unRealizedProfit']):+.2f}")
            return
    print("No open position")

def get_mode():
    data = signed_req("GET", "/fapi/v1/positionSide/dual")
    return "HEDGE" if data.get("dualSidePosition", False) else "ONE_WAY"

def setup():
    print("Setting leverage...")
    print(signed_req("POST", "/fapi/v1/leverage", {"symbol": SYMBOL, "leverage": LEVERAGE}))
    print("Setting margin type...")
    print(signed_req("POST", "/fapi/v1/marginType", {"symbol": SYMBOL, "marginType": MARGIN_TYPE}))

def print_help():
    print(f"""
symbol = {SYMBOL}   qty prec = {symbol_prec['qty']}   minNotional ~ {symbol_info.get('minNotional', '?')} USDT

Commands:

  python bot.py balance           futures USDT balance
  python bot.py positions         show current position
  python bot.py setup             set leverage + margin type
  python bot.py buy     [qty]     open LONG (market)
  python bot.py sell    [qty]     open SHORT (market)
  python bot.py long_cycle  [qty] open LONG → close it
  python bot.py short_cycle [qty] open SHORT → close it
  python bot.py mode              show position mode
  python bot.py time              server time

No arguments → this help
""")

if __name__ == "__main__":
    load_symbol()

    args = sys.argv[1:]
    if not args:
        print_help()
        sys.exit(0)

    cmd = args[0].lower()
    qty = float(args[1]) if len(args) > 1 else None

    if cmd == "balance":
        print(f"Available USDT: {get_balance():.2f}")

    elif cmd == "positions" or cmd == "pos":
        get_pos()

    elif cmd == "setup":
        setup()

    elif cmd == "buy":
        place_market("BUY", qty)
        time.sleep(2)
        get_pos()

    elif cmd == "sell":
        place_market("SELL", qty)
        time.sleep(2)
        get_pos()

    elif cmd == "long_cycle":
        if get_mode() == "HEDGE":
            print("Hedge mode detected — cycle assumes One-way mode")
        else:
            print("LONG cycle")
            place_market("BUY", qty)
            time.sleep(3)
            get_pos()
            place_market("SELL", None, reduce_only=True)
            time.sleep(2)
            get_pos()

    elif cmd == "short_cycle":
        if get_mode() == "HEDGE":
            print("Hedge mode detected — cycle assumes One-way mode")
        else:
            print("SHORT cycle")
            place_market("SELL", qty)
            time.sleep(3)
            get_pos()
            place_market("BUY", None, reduce_only=True)
            time.sleep(2)
            get_pos()

    elif cmd == "mode":
        print("Position mode:", get_mode())

    elif cmd == "time":
        data = requests.get(f"{BASE_URL}/fapi/v1/time").json()
        ts = data.get("serverTime", 0)
        print(time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(ts / 1000)))

    else:
        print(f"Unknown command: {cmd}")
        print_help()
