# bot.py
# Binance USDS-M Futures ‚Äì Telegram controlled bot
# Strategy: EMA(14) ‚Üí RSI(14 on EMA) ‚Üí SMA(5 on RSI) on 1m
# Only TP 0.6% (no SL)
# Symbols added manually via Telegram (/add BTCUSDT etc.)

import time
import logging
import requests
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Dict, Set, Optional
import pandas as pd
import numpy as np
import math
from ta.trend import EMAIndicator
from ta.momentum import RSIIndicator
from datetime import datetime, timedelta, timezone
import asyncio

# ‚îÄ‚îÄ Telegram imports ‚îÄ‚îÄ
from telegram import Update, Bot
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Config
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg  = config.get("binance",  {})
telegram_cfg = config.get("telegram", {})
trading_cfg  = config.get("trading",  {})

API_KEY         = binance_cfg.get("api_key")
API_SECRET      = binance_cfg.get("api_secret")
TELEGRAM_TOKEN  = telegram_cfg.get("token")
TELEGRAM_CHAT_ID = telegram_cfg.get("chat_id")

USE_TESTNET = trading_cfg.get("use_testnet", True)

if USE_TESTNET:
    BASE_URL = "https://testnet.binancefuture.com"
    print("=== TESTNET MODE ===")
else:
    BASE_URL = "https://fapi.binance.com"
    print("=== MAINNET ‚Äì REAL MONEY ===")

FIXED_LEVERAGE   = 5
FIXED_MARGIN_TYPE = "ISOLATED"
CHECK_INTERVAL_SECONDS = 60
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -15.0)
TAKE_PROFIT_PCT        = 0.006   # 0.6%

if not all([API_KEY, API_SECRET, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID]):
    print("ERROR: Missing keys in config.yaml")
    exit(1)

HEADERS = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s  %(levelname)-8s  %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

telegram_bot = Bot(token=TELEGRAM_TOKEN)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# State
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

monitored_symbols: Set[str] = set()
configured: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}
symbol_entry_price: Dict[str, Optional[float]] = {}
symbol_tp_order_id: Dict[str, Optional[int]] = {}
last_entry_time: Dict[str, Optional[datetime]] = {}

_price_precision_cache: Dict[str, int] = {}
_qty_precision_cache: Dict[str, int] = {}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram notification
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def send_telegram(msg: str, silent: bool = True):
    try:
        await telegram_bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=msg,
            disable_notification=silent
        )
    except Exception as e:
        logger.error(f"Telegram send failed: {e}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Binance API helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def signed_request(method: str, endpoint: str, params: Dict = None) -> dict:
    if params is None: params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000
    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        elif method.upper() == "DELETE":
            r = requests.delete(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Unsupported method")
        r.raise_for_status()
        data = r.json()
        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {endpoint}: {data}")
        return data
    except Exception as e:
        logger.error(f"Request failed {endpoint}: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None: params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed {endpoint}: {e}")
        return []

def symbol_exists_on_exchange(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict) or "symbols" not in data:
        return False
    for s in data["symbols"]:
        if s["symbol"] == symbol and s.get("status") == "TRADING":
            return True
    return False

def get_price_precision(symbol: str) -> int:
    if symbol in _price_precision_cache:
        return _price_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f["tickSize"])
                    prec = max(0, -int(math.log10(tick)))
                    _price_precision_cache[symbol] = prec
                    return prec
    _price_precision_cache[symbol] = 4
    return 4

def get_qty_precision(symbol: str) -> int:
    if symbol in _qty_precision_cache:
        return _qty_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    step = float(f["stepSize"])
                    prec = max(0, -int(math.log10(step)))
                    _qty_precision_cache[symbol] = prec
                    return prec
    _qty_precision_cache[symbol] = 3
    return 3

def ensure_leverage_and_margin(symbol: str) -> bool:
    if symbol in configured:
        return True
    pos_data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(pos_data, dict) and "code" in pos_data and pos_data["code"] == -1121:
        logger.error(f"Symbol {symbol} invalid / not found on exchange")
        return False
    if not isinstance(pos_data, list) or not pos_data:
        return False
    pos = pos_data[0]
    success = True
    if int(pos.get("leverage", 0)) != FIXED_LEVERAGE:
        r = signed_request("POST", "/fapi/v1/leverage", {"symbol": symbol, "leverage": FIXED_LEVERAGE})
        success &= "code" not in r or r["code"] >= 0
    if pos.get("isolated", False) != (FIXED_MARGIN_TYPE == "ISOLATED"):
        r = signed_request("POST", "/fapi/v1/marginType", {"symbol": symbol, "marginType": FIXED_MARGIN_TYPE})
        success &= "code" not in r or r["code"] >= 0
    if success:
        configured.add(symbol)
    return success

def get_current_position_data(symbol: str) -> dict:
    data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(data, list) and data:
        pos = data[0]
        if abs(float(pos.get("positionAmt", "0"))) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        real_side = "LONG" if float(pos["positionAmt"]) > 0 else "SHORT"
    if real_side != symbol_position_state.get(symbol):
        cancel_take_profit(symbol)
        symbol_position_state[symbol] = real_side
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        last_entry_time[symbol] = datetime.now(timezone.utc)

def cancel_take_profit(symbol: str) -> bool:
    oid = symbol_tp_order_id.get(symbol)
    if not oid:
        return True

    params = {
        "symbol": symbol,
        "orderId": int(oid),  # ensure integer
        "recvWindow": 5000,
    }

    resp = signed_request("DELETE", "/fapi/v1/order", params)

    if isinstance(resp, dict):
        code = resp.get("code")
        msg = resp.get("msg", "")

        if code in (-2011, -2013):  # Order does not exist / already cancelled
            logger.info(f"Cancel TP {symbol} order {oid}: already gone ({msg})")
            symbol_tp_order_id[symbol] = None
            return True

        if code is not None and code < 0:
            logger.error(f"Cancel TP failed {symbol} #{oid}: code={code} msg={msg} full_resp={resp}")
            return False

    if "orderId" in resp:
        logger.info(f"Cancelled TP {symbol} order {oid}")
        symbol_tp_order_id[symbol] = None
        return True

    logger.warning(f"Unexpected cancel response for {symbol} #{oid}: {resp}")
    return False

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    return float(data.get("markPrice", 0)) if isinstance(data, dict) else 0.0

def get_klines(symbol: str, limit: int = 100) -> list:
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params={
            "symbol": symbol,
            "interval": "1m",
            "limit": limit
        }, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines {symbol}: {e}")
        return []

def calculate_safe_quantity(symbol: str) -> float:
    data = public_get("/fapi/v1/exchangeInfo")
    min_notional = 5.0
    step_size = 0.001
    min_qty = 0.001
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    min_qty = float(f["minQty"])
                    step_size = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    min_notional = float(f.get("notional", 5.0))
            break
    price = get_current_price(symbol)
    if price <= 0:
        return 0.001
    target = min_notional * 1.2
    raw = target / price
    steps = math.ceil(raw / step_size)
    qty = max(steps * step_size, min_qty)
    return round(qty, get_qty_precision(symbol))

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> dict:
    if qty <= 0:
        return {"error": "Invalid qty"}
    qstr = f"{qty:.{get_qty_precision(symbol)}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    resp = signed_request("POST", "/fapi/v1/order", params)
    if "orderId" in resp:
        logger.info(f"Placed MARKET {side} {symbol} qty={qstr} orderId={resp['orderId']}")
    elif "code" in resp and resp["code"] == -1121:
        logger.error(f"Invalid symbol {symbol} - order failed")
        asyncio.create_task(send_telegram(f"‚ö†Ô∏è Invalid symbol {symbol} - cannot place order"))
    return resp

def place_take_profit_order(symbol: str, side: str, qty: float, price: float) -> dict:
    pstr = f"{price:.{get_price_precision(symbol)}f}".rstrip("0").rstrip(".")
    qstr = f"{qty:.{get_qty_precision(symbol)}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    resp = signed_request("POST", "/fapi/v1/order", params)
    if "orderId" in resp:
        logger.info(f"Placed TP {symbol} {side} @ {pstr} qty={qstr} orderId={resp['orderId']}")
    elif "code" in resp and resp["code"] == -1121:
        logger.error(f"Invalid symbol {symbol} - TP order failed")
        asyncio.create_task(send_telegram(f"‚ö†Ô∏è Invalid symbol {symbol} - cannot place TP"))
    return resp

def close_position(symbol: str, reason: str = "manual") -> bool:
    pos = get_current_position_data(symbol)
    if not pos:
        return True
    amt = float(pos["positionAmt"])
    side = "SELL" if amt > 0 else "BUY"
    qty = abs(amt)
    resp = place_market_order(symbol, side, qty, reduce_only=True)
    success = resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED")
    if success:
        cancel_take_profit(symbol)
        symbol_position_state[symbol] = None
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        last_entry_time[symbol] = datetime.now(timezone.utc)
        asyncio.create_task(send_telegram(f"Closed {symbol} ({reason})"))
    return success

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram commands
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = (
        "EMA(14) ‚Üí RSI(14 on EMA) ‚Üí SMA(5 on RSI) 1m bot\n"
        "Entry: SMA(5) rising ‚Üí LONG / falling ‚Üí SHORT\n"
        "Reverse: RSI slope changes direction\n"
        "Only TP +0.6% (no SL)\n\n"
        "Commands:\n"
        "  /add BTCUSDT\n"
        "  /rem BTCUSDT\n"
        "  /reset\n"
        "  /list"
    )
    await update.message.reply_text(text)

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add BTCUSDT")
        return
    sym = context.args[0].strip().upper()
    if sym in monitored_symbols:
        await update.message.reply_text(f"{sym} already monitored")
        return
    
    if not symbol_exists_on_exchange(sym):
        await update.message.reply_text(f"Symbol {sym} does NOT exist or is not trading on this exchange (testnet/mainnet). Check spelling or availability.")
        await send_telegram(f"Rejected add: {sym} ‚Äì invalid symbol", silent=False)
        return
    
    if ensure_leverage_and_margin(sym):
        monitored_symbols.add(sym)
        symbol_position_state[sym] = None
        await update.message.reply_text(f"Added {sym}")
        await send_telegram(f"Added symbol: {sym}", silent=True)
    else:
        await update.message.reply_text(f"Failed to configure {sym}")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /rem BTCUSDT")
        return
    sym = context.args[0].strip().upper()
    if sym not in monitored_symbols:
        await update.message.reply_text(f"{sym} not found")
        return
    closed = close_position(sym, "manual remove")
    monitored_symbols.remove(sym)
    symbol_position_state.pop(sym, None)
    symbol_entry_price.pop(sym, None)
    symbol_tp_order_id.pop(sym, None)
    configured.discard(sym)
    last_entry_time.pop(sym, None)
    msg = f"Removed {sym}"
    if closed:
        msg += " + closed position"
    await update.message.reply_text(msg)
    await send_telegram(f"Removed: {sym}", silent=True)

async def cmd_reset(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    for sym in list(monitored_symbols):
        close_position(sym, "reset")
    monitored_symbols.clear()
    symbol_position_state.clear()
    symbol_entry_price.clear()
    symbol_tp_order_id.clear()
    configured.clear()
    last_entry_time.clear()
    await update.message.reply_text("Reset complete ‚Äì all symbols cleared")
    await send_telegram("Bot reset ‚Äì all symbols removed", silent=False)

async def cmd_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not monitored_symbols:
        await update.message.reply_text("No symbols monitored.\nUse /add <SYMBOL>")
        return
    lines = ["Monitored:"]
    for sym in sorted(monitored_symbols):
        side = symbol_position_state.get(sym, "‚Äî")
        lines.append(f"  {sym}  {side}")
    await update.message.reply_text("\n".join(lines))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Trading loop
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def trading_loop(_: Application) -> None:
    logger.info(f"Started ‚Äì monitoring {len(monitored_symbols)} symbols")
    await send_telegram("Bot started ‚Äì use /add to begin trading", silent=False)

    while True:
        for symbol in list(monitored_symbols):
            try:
                if not symbol_exists_on_exchange(symbol):
                    logger.error(f"Symbol {symbol} no longer valid - removing")
                    await send_telegram(f"‚ö†Ô∏è Symbol {symbol} invalid - removed automatically")
                    monitored_symbols.remove(symbol)
                    continue

                sync_position_state(symbol)
                current_side = symbol_position_state.get(symbol)

                pos = get_current_position_data(symbol)
                if pos:
                    pnl = float(pos.get("unRealizedProfit", 0))
                    if pnl < MAX_ALLOWED_LOSS_USDT:
                        close_position(symbol, "max loss cut")
                        await send_telegram(f"‚ö†Ô∏è LOSS CUT {symbol} PnL {pnl:.2f}")
                        continue

                qty = calculate_safe_quantity(symbol)
                if qty < 1e-5:
                    continue

                klines = get_klines(symbol)
                if not klines or len(klines) < 40:
                    continue

                df = pd.DataFrame(klines, columns=[
                    "ot","open","high","low","close","vol",
                    "ct","qv","n","tbv","tqv","i"
                ])
                df["close"] = df["close"].astype(float)

                ema14 = EMAIndicator(df["close"], 14).ema_indicator()
                rsi14 = RSIIndicator(ema14, 14).rsi()
                sma5  = rsi14.rolling(5).mean()

                if len(sma5.dropna()) < 3:
                    continue

                last_sma = sma5.iloc[-2]
                prev_sma = sma5.iloc[-3]
                last_rsi = rsi14.iloc[-2]
                prev_rsi = rsi14.iloc[-3]

                mark_price = get_current_price(symbol)
                if mark_price <= 0:
                    continue

                can_enter = True
                if symbol in last_entry_time and last_entry_time[symbol]:
                    if datetime.now(timezone.utc) - last_entry_time[symbol] < timedelta(seconds=90):
                        can_enter = False

                if current_side is None and can_enter:
                    if last_sma > prev_sma:
                        resp = place_market_order(symbol, "BUY", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "LONG"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                            tp_resp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                            if "orderId" in tp_resp:
                                symbol_tp_order_id[symbol] = tp_resp["orderId"]
                            await send_telegram(
                                f"üü¢ LONG {symbol} @ {mark_price:.6f} TP {tp_price:.6f}",
                                silent=False
                            )
                            last_entry_time[symbol] = datetime.now(timezone.utc)
                        elif "code" in resp and resp["code"] == -1121:
                            monitored_symbols.remove(symbol)

                    elif last_sma < prev_sma:
                        resp = place_market_order(symbol, "SELL", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "SHORT"
                            symbol_entry_price[symbol] = mark_price
                            tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                            tp_resp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                            if "orderId" in tp_resp:
                                symbol_tp_order_id[symbol] = tp_resp["orderId"]
                            await send_telegram(
                                f"üî¥ SHORT {symbol} @ {mark_price:.6f} TP {tp_price:.6f}",
                                silent=False
                            )
                            last_entry_time[symbol] = datetime.now(timezone.utc)
                        elif "code" in resp and resp["code"] == -1121:
                            monitored_symbols.remove(symbol)

                elif current_side == "LONG" and last_rsi < prev_rsi:
                    close_position(symbol, "RSI reversal")
                    await send_telegram(f"üîÑ {symbol} LONG ‚Üí SHORT")
                    resp = place_market_order(symbol, "SELL", qty)
                    if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                        symbol_position_state[symbol] = "SHORT"
                        symbol_entry_price[symbol] = mark_price
                        tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                        tp_resp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                        if "orderId" in tp_resp:
                            symbol_tp_order_id[symbol] = tp_resp["orderId"]
                        await send_telegram(f"üî¥ SHORT {symbol} (reversal)", silent=False)
                        last_entry_time[symbol] = datetime.now(timezone.utc)
                    elif "code" in resp and resp["code"] == -1121:
                        monitored_symbols.remove(symbol)

                elif current_side == "SHORT" and last_rsi > prev_rsi:
                    close_position(symbol, "RSI reversal")
                    await send_telegram(f"üîÑ {symbol} SHORT ‚Üí LONG")
                    resp = place_market_order(symbol, "BUY", qty)
                    if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                        symbol_position_state[symbol] = "LONG"
                        symbol_entry_price[symbol] = mark_price
                        tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                        tp_resp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                        if "orderId" in tp_resp:
                            symbol_tp_order_id[symbol] = tp_resp["orderId"]
                        await send_telegram(f"üü¢ LONG {symbol} (reversal)", silent=False)
                        last_entry_time[symbol] = datetime.now(timezone.utc)
                    elif "code" in resp and resp["code"] == -1121:
                        monitored_symbols.remove(symbol)

                # Detect TP / external close
                if current_side and symbol_entry_price.get(symbol):
                    if float(pos.get("positionAmt", "0")) == 0:
                        entry = symbol_entry_price[symbol]
                        exit_price = float(pos.get("markPrice", mark_price))
                        pnl_pct = (exit_price - entry) / entry * 100 if current_side == "LONG" else (entry - exit_price) / entry * 100
                        msg = f"‚úÖ TP hit {symbol} {current_side} | PnL {pnl_pct:+.2f}%"
                        if not symbol_tp_order_id.get(symbol):
                            msg = f"External close {symbol} {current_side} | PnL {pnl_pct:+.2f}%"
                        await send_telegram(msg, silent=False)
                        symbol_position_state[symbol] = None
                        symbol_entry_price[symbol] = None
                        symbol_tp_order_id[symbol] = None
                        last_entry_time[symbol] = datetime.now(timezone.utc)

            except Exception as e:
                logger.error(f"[{symbol}] {e}")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Startup
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def on_startup(app: Application) -> None:
    asyncio.create_task(trading_loop(app))
    logger.info("Trading loop started")

def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("add",   cmd_add))
    app.add_handler(CommandHandler("rem",   cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_reset))
    app.add_handler(CommandHandler("list",  cmd_list))
    app.post_init = on_startup
    print("Starting bot...")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
