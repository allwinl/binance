# bot.py
# Binance USDS-M Futures Telegram bot – auto check every 30 seconds
# Dynamic quantity + loss-cut + real position sync + auto-reverse

import asyncio
import logging
from datetime import datetime, timezone
import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Optional, Dict, Set
import pandas as pd
import math
from ta.trend import EMAIndicator   # pip install ta
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# ────────────────────────────────────────────────
# Load config
# ────────────────────────────────────────────────

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg = config.get("binance", {})
telegram_cfg = config.get("telegram", {})
trading_cfg = config.get("trading", {})

API_KEY        = binance_cfg.get("api_key")
API_SECRET     = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")

LEVERAGE         = trading_cfg.get("leverage", 5)
MARGIN_TYPE      = trading_cfg.get("margin_type", "ISOLATED").upper()
CHECK_INTERVAL_SECONDS = 30
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -10.0)

if not API_KEY or not API_SECRET or not TELEGRAM_TOKEN:
    print("ERROR: Missing api_key, api_secret or telegram token")
    exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ────────────────────────────────────────────────
# State
# ────────────────────────────────────────────────

monitored_symbols: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}  # "LONG", "SHORT" or None

# ────────────────────────────────────────────────
# Binance helpers
# ────────────────────────────────────────────────

def signed_request(method: str, endpoint: str, params: Dict = None) -> Dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {data['code']}: {data.get('msg')}")
        return data
    except Exception as e:
        logger.error(f"Request failed: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None:
        params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed: {e}")
        return []

def get_symbol_filters(symbol: str) -> dict:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return {}
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            filters = {}
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    filters["minQty"] = float(f["minQty"])
                    filters["stepSize"] = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    filters["minNotional"] = float(f.get("notional", 5.0))
            return filters
    return {}

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    if isinstance(data, dict) and "markPrice" in data:
        return float(data["markPrice"])
    return 0.0

def calculate_safe_quantity(symbol: str) -> float:
    filters = get_symbol_filters(symbol)
    if not filters:
        logger.warning(f"No filters for {symbol} → fallback 0.001")
        return 0.001

    min_notional = filters.get("minNotional", 5.0)
    step_size    = filters.get("stepSize", 0.1)
    min_qty      = filters.get("minQty", 0.1)
    price        = get_current_price(symbol)

    if price <= 0:
        logger.warning(f"No price for {symbol} → fallback 0.001")
        return 0.001

    target = min_notional * 1.05
    raw_qty = target / price
    steps = math.ceil(raw_qty / step_size)
    final_qty = steps * step_size
    final_qty = max(final_qty, min_qty)

    logger.info(f"[{symbol}] qty = {final_qty:.6f} (~{target:.2f} USDT notional)")
    return round(final_qty, 6)

def get_current_position_data(symbol: str) -> dict:
    params = {"symbol": symbol}
    data = signed_request("GET", "/fapi/v2/positionRisk", params)
    if isinstance(data, list) and data:
        pos = data[0]
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        amt = float(pos.get("positionAmt", "0"))
        real_side = "LONG" if amt > 0 else "SHORT"

    current = symbol_position_state.get(symbol, None)
    if real_side != current:
        logger.info(f"Sync {symbol}: {current or 'None'} → {real_side or 'None'}")
        symbol_position_state[symbol] = real_side

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            if s.get("contractType") == "PERPETUAL" and s.get("status") == "TRADING":
                return True
    return False

def get_klines(symbol: str, interval: str, limit: int = 100) -> list:
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines failed for {symbol} {interval}: {e}")
        return []

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> Dict:
    if qty <= 0:
        return {"error": "Invalid quantity"}

    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")

    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    logger.info(f"Order: {side.upper()} {qstr} {symbol} reduceOnly={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def close_all_positions():
    positions = signed_request("GET", "/fapi/v2/positionRisk")
    if not isinstance(positions, list):
        return []

    closed = []
    for pos in positions:
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) <= POSITION_TOLERANCE:
            continue

        sym = pos["symbol"]
        side = "SELL" if amt > 0 else "BUY"
        qty = abs(amt)
        resp = place_market_order(sym, side, qty, reduce_only=True)

        if resp.get("status") in ("NEW", "FILLED"):
            symbol_position_state[sym] = None

        closed.append((sym, resp))

    return closed

# ────────────────────────────────────────────────
# Telegram Handlers – defined BEFORE main()
# ────────────────────────────────────────────────

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Futures EMA-3 bot – auto-reverse + loss-cut + dynamic qty\n\n"
        f"• Checks every {CHECK_INTERVAL_SECONDS} seconds\n"
        f"• Closes if unrealized PnL < {MAX_ALLOWED_LOSS_USDT} USDT\n"
        "• Quantity ≈ 5% above min notional\n\n"
        "Commands:\n"
        "/add SYMBOL\n"
        "/rem SYMBOL\n"
        "/rem or /reset   (close all + clear)\n"
        "/test SYMBOL     (manual full cycle)\n"
    )

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add XRPUSDT")
        return

    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT perpetual symbols")
        return

    if symbol_is_valid_perp(sym):
        if sym in monitored_symbols:
            await update.message.reply_text(f"{sym} already monitored")
        else:
            monitored_symbols.add(sym)
            symbol_position_state.setdefault(sym, None)
            await update.message.reply_text(
                f"Added {sym}\nCurrent list: {', '.join(sorted(monitored_symbols)) or 'empty'}"
            )
    else:
        await update.message.reply_text(f"{sym} not valid or not trading")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        old_list = sorted(monitored_symbols)
        monitored_symbols.clear()
        symbol_position_state.clear()

        closed = close_all_positions()

        text = "Reset complete.\n"
        if old_list:
            text += f"Removed symbols: {', '.join(old_list)}\n"
        else:
            text += "No symbols were monitored.\n"

        if closed:
            text += "Closed positions:\n" + "\n".join([f"• {s}: {r.get('msg', 'ok')}" for s, r in closed])
        else:
            text += "No open positions found."

        await update.message.reply_text(text)
        return

    sym = context.args[0].strip().upper()
    if sym in monitored_symbols:
        monitored_symbols.remove(sym)
        symbol_position_state.pop(sym, None)
        await update.message.reply_text(
            f"Removed {sym}\n"
            f"Current list: {', '.join(sorted(monitored_symbols)) or 'empty'}"
        )
    else:
        await update.message.reply_text(f"{sym} not in list")

async def cmd_test(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /test XRPUSDT")
        return

    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT symbols")
        return

    if not symbol_is_valid_perp(sym):
        await update.message.reply_text(f"{sym} not valid perpetual futures pair")
        return

    qty = calculate_safe_quantity(sym)
    if qty <= 0:
        await update.message.reply_text("Cannot calculate quantity")
        return

    await update.message.reply_text(
        f"Test cycle {sym}\n"
        f"Quantity: {qty:.6f}\n"
        "Starting LONG → close → SHORT → close ...\n"
    )

    await update.message.reply_text("1/4 Opening LONG...")
    open_long = place_market_order(sym, "BUY", qty)
    await update.message.reply_text(f"Open LONG: {open_long.get('status', 'unknown')} {open_long.get('orderId', '')}")

    await asyncio.sleep(4)

    await update.message.reply_text("2/4 Closing LONG...")
    close_long = place_market_order(sym, "SELL", qty, reduce_only=True)
    await update.message.reply_text(f"Close LONG: {close_long.get('status', 'unknown')} {close_long.get('orderId', '')}")

    await asyncio.sleep(3)

    await update.message.reply_text("3/4 Opening SHORT...")
    open_short = place_market_order(sym, "SELL", qty)
    await update.message.reply_text(f"Open SHORT: {open_short.get('status', 'unknown')} {open_short.get('orderId', '')}")

    await asyncio.sleep(4)

    await update.message.reply_text("4/4 Closing SHORT...")
    close_short = place_market_order(sym, "BUY", qty, reduce_only=True)
    await update.message.reply_text(f"Close SHORT: {close_short.get('status', 'unknown')} {close_short.get('orderId', '')}")

    await update.message.reply_text("Test cycle finished.")

async def handle_symbol_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text.strip().upper()
    if text.startswith('/') or len(text) < 4 or not text.endswith("USDT"):
        return

    symbol = text

    if symbol not in monitored_symbols:
        await update.message.reply_text(f"{symbol} not monitored. Use /add first.")
        return

    current_side = symbol_position_state.get(symbol, None)
    if current_side is not None:
        await update.message.reply_text(f"Already {current_side} on {symbol} – skipped")
        return

    await update.message.reply_text(f"Manual check: {symbol}")

    klines_1m = get_klines(symbol, "1m", 50)
    if not klines_1m or len(klines_1m) < 3:
        await update.message.reply_text("Not enough 1m data")
        return

    klines_1d = get_klines(symbol, "5m", 2)
    if not klines_1d:
        await update.message.reply_text("Failed to get 1d data")
        return

    today_open = float(klines_1d[-1][1])
    closes = [float(k[4]) for k in klines_1m]

    df = pd.DataFrame({"close": closes})
    ema_indicator = EMAIndicator(close=df["close"], window=3)
    ema_value = ema_indicator.ema_indicator().iloc[-1]

    qty = calculate_safe_quantity(symbol)

    msg = (
        f"**Manual check {symbol}**\n"
        f"1d open: {today_open:.4f}\n"
        f"EMA-3: {ema_value:.4f}\n"
        f"Quantity: {qty:.6f}\n"
    )

    if ema_value > today_open:
        msg += "→ opening LONG"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "BUY", qty)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "LONG"
    elif ema_value < today_open:
        msg += "→ opening SHORT"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "SELL", qty)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "SHORT"
    else:
        msg += "→ no action"
        await update.message.reply_text(msg)

# ────────────────────────────────────────────────
# Auto-check loop
# ────────────────────────────────────────────────

async def auto_check_symbols(app: Application) -> None:
    while True:
        if monitored_symbols:
            logger.info(f"Auto-checking {len(monitored_symbols)} symbols...")
            for symbol in list(monitored_symbols):
                try:
                    sync_position_state(symbol)
                    current_side = symbol_position_state.get(symbol, None)

                    pos_data = get_current_position_data(symbol)
                    if pos_data:
                        pnl = float(pos_data.get("unRealizedProfit", 0))
                        if pnl < MAX_ALLOWED_LOSS_USDT:
                            logger.warning(f"[{symbol}] LOSS CUT! PnL {pnl:.2f}")
                            side = "SELL" if current_side == "LONG" else "BUY"
                            qty = abs(float(pos_data["positionAmt"]))
                            close_resp = place_market_order(symbol, side, qty, reduce_only=True)
                            if close_resp.get("status") in ("NEW", "FILLED"):
                                symbol_position_state[symbol] = None
                            continue

                    klines_1m = get_klines(symbol, "1m", 50)
                    if not klines_1m or len(klines_1m) < 3:
                        continue

                    klines_1d = get_klines(symbol, "1d", 2)
                    if not klines_1d:
                        continue

                    today_open = float(klines_1d[-1][1])
                    closes = [float(k[4]) for k in klines_1m]

                    df = pd.DataFrame({"close": closes})
                    ema_indicator = EMAIndicator(close=df["close"], window=3)
                    ema_value = ema_indicator.ema_indicator().iloc[-1]

                    logger.info(
                        f"[{symbol}] 1d open: {today_open:.4f} | EMA-3: {ema_value:.4f} | pos: {current_side or 'None'}"
                    )

                    should_long  = ema_value > today_open
                    should_short = ema_value < today_open

                    qty = calculate_safe_quantity(symbol)

                    if current_side is None:
                        if should_long:
                            logger.info(f"→ {symbol} open LONG")
                            resp = place_market_order(symbol, "BUY", qty)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"
                        elif should_short:
                            logger.info(f"→ {symbol} open SHORT")
                            resp = place_market_order(symbol, "SELL", qty)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"

                    elif current_side == "LONG" and should_short:
                        logger.info(f"→ {symbol} reverse LONG → SHORT")
                        close_resp = place_market_order(symbol, "SELL", qty, reduce_only=True)
                        if close_resp.get("status") in ("NEW", "FILLED"):
                            open_resp = place_market_order(symbol, "SELL", qty)
                            if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"

                    elif current_side == "SHORT" and should_long:
                        logger.info(f"→ {symbol} reverse SHORT → LONG")
                        close_resp = place_market_order(symbol, "BUY", qty, reduce_only=True)
                        if close_resp.get("status") in ("NEW", "FILLED"):
                            open_resp = place_market_order(symbol, "BUY", qty)
                            if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"

                except Exception as e:
                    logger.error(f"Error checking {symbol}: {e}")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ────────────────────────────────────────────────
# Startup hook
# ────────────────────────────────────────────────

async def on_startup(app: Application) -> None:
    asyncio.create_task(auto_check_symbols(app))
    logger.info(f"Auto-check started – interval {CHECK_INTERVAL_SECONDS}s")

# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────

def main() -> None:
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("add", cmd_add))
    app.add_handler(CommandHandler("rem", cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))
    app.add_handler(CommandHandler("test", cmd_test))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_symbol_message))

    app.post_init = on_startup

    print("Bot starting...")
    print("Monitored:", monitored_symbols)
    print("States:", symbol_position_state)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
