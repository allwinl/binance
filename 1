# bot.py
# Simple EMA vs Daily Open strategy – Binance USDS-M Futures
# Reads ALL settings from config.py

import time
import logging
from datetime import datetime
import pandas as pd

try:
    from binance.futures import Futures
    from binance.error import ClientError
except ImportError:
    print("Please install:  pip install binance-sdk-derivatives-trading-usds-futures")
    exit(1)

import config

# ─── Logging ────────────────────────────────────────────────
logging.basicConfig(
    filename='trading_bot.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ─── Binance client ─────────────────────────────────────────
if config.RUN_LIVE:
    client = Futures(key=config.API_KEY, secret=config.API_SECRET)
    print(">>> LIVE MODE – REAL MONEY – USE WITH EXTREME CAUTION <<<")
    logger.warning("BOT STARTED IN LIVE MODE")
else:
    print(">>> DRY RUN MODE – no real orders will be placed <<<")
    logger.info("Dry run mode active – no orders sent")

# ─── Helper functions ───────────────────────────────────────

def get_klines(symbol, interval, limit=300):
    try:
        data = client.klines(symbol, interval, limit=limit)
        df = pd.DataFrame(data, columns=[
            'ot','o','h','l','c','v','ct','qv','n','tbv','tqv','x'
        ])
        df = df.astype({'o':'float','h':'float','l':'float','c':'float'})
        return df
    except Exception as e:
        logger.error(f"klines failed: {e}")
        return None


def get_daily_open(symbol):
    try:
        data = client.klines(symbol, "1d", limit=2)
        return float(data[-1][1])   # open price of current day candle
    except Exception as e:
        logger.error(f"daily open failed: {e}")
        return None


def get_position(symbol):
    try:
        pos = client.get_position_risk(symbol=symbol)
        if pos and len(pos) > 0:
            return float(pos[0]['positionAmt'])
        return 0.0
    except Exception as e:
        logger.error(f"position query failed: {e}")
        return 0.0


def get_usdt_available():
    try:
        acc = client.account()
        for a in acc['assets']:
            if a['asset'] == 'USDT':
                return float(a['availableBalance'])
        return 0.0
    except Exception as e:
        logger.error(f"balance query failed: {e}")
        return 0.0


def market_order(symbol, side, qty):
    if not config.RUN_LIVE:
        logger.info(f"DRY RUN – would place {side} order | qty = {qty:.3f}")
        print(  f"DRY RUN – would place {side} order | qty = {qty:.3f}")
        return None

    qty = round(qty, 3)
    try:
        order = client.new_order(
            symbol=symbol,
            side=side.upper(),
            type="MARKET",
            quantity=qty
        )
        msg = f"ORDER OK → {side.upper()} {qty:.3f} {symbol}"
        logger.info(msg)
        print(msg)
        return order
    except ClientError as e:
        logger.error(f"order failed: {e}")
        print(f"order failed: {e}")
        return None


# ─── Strategy logic ─────────────────────────────────────────

def run_once():
    df = get_klines(config.SYMBOL, config.INTERVAL)
    if df is None or len(df) < config.EMA_PERIOD + 10:
        logger.warning("not enough candles")
        return

    df['ema'] = df['c'].ewm(span=config.EMA_PERIOD, adjust=False).mean()

    price = df['c'].iloc[-1]
    ema   = df['ema'].iloc[-1]
    daily_open = get_daily_open(config.SYMBOL)

    if daily_open is None:
        return

    now_str = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    print(f"{now_str} | price {price:,.2f} | ema{config.EMA_PERIOD} {ema:,.2f} | open {daily_open:,.2f}")
    logger.info(f"price {price:,.2f} | ema {ema:,.2f} | daily open {daily_open:,.2f}")

    position = get_position(config.SYMBOL)
    dist = abs(price - daily_open) / daily_open

    usdt = get_usdt_available()

    if usdt < config.MIN_SAFE_BALANCE:
        if position != 0:
            side = "SELL" if position > 0 else "BUY"
            logger.critical(f"EMERGENCY CLOSE – balance too low {usdt:.2f}")
            market_order(config.SYMBOL, side, abs(position))
        return

    # Entry / exit logic
    if position == 0:
        if price > ema and dist < config.DAILY_OPEN_TOLERANCE * 1.8 and price >= daily_open * (1 - config.DAILY_OPEN_TOLERANCE):
            qty = (usdt * config.POSITION_PCT * config.LEVERAGE) / price
            if qty > 0.001:
                logger.info(f"LONG signal → qty ~ {qty:.3f}")
                market_order(config.SYMBOL, "BUY", qty)

        elif price < ema and price <= daily_open * (1 - config.DAILY_OPEN_TOLERANCE):
            qty = (usdt * config.POSITION_PCT * config.LEVERAGE) / price
            if qty > 0.001:
                logger.info(f"SHORT signal → qty ~ {qty:.3f}")
                market_order(config.SYMBOL, "SELL", qty)

    elif position > 0 and price < ema * 0.988:
        logger.info("close LONG")
        market_order(config.SYMBOL, "SELL", abs(position))

    elif position < 0 and price > ema * 1.012:
        logger.info("close SHORT")
        market_order(config.SYMBOL, "BUY", abs(position))


# ─── Main loop ──────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting bot – {config.SYMBOL} {config.INTERVAL}  EMA{config.EMA_PERIOD}")
    logger.info(f"Bot started – {config.SYMBOL}  live={config.RUN_LIVE}")

    try:
        client.change_leverage(symbol=config.SYMBOL, leverage=config.LEVERAGE)
        print(f"Leverage set to {config.LEVERAGE}x")
    except Exception as e:
        if "2024" not in str(e):
            print("leverage set warning:", e)

    while True:
        try:
            run_once()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            break
        except Exception as e:
            logger.error(f"main loop error: {e}", exc_info=True)
            print("error:", e)

        time.sleep(config.SLEEP_SECONDS)
