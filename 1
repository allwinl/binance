# bot.py
# Binance USDS-M Futures – ORDER PLACEMENT TEST ONLY
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION
# Forced open/close cycle – no trading signals

import time
import logging
from datetime import datetime, timezone

# Official SDK for trading/account
try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing official SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # must contain: API_KEY, API_SECRET  (HEDGE_MODE is optional)

# ─── Config for TEST ────────────────────────────────────────────────────────
TEST_MODE            = True
SYMBOL               = "XRPUSDT"
TEST_QUANTITY        = 10.0             # very small – change to 5 or 2 if needed
LEVERAGE             = 3
SLEEP_SECONDS        = 10

# ─── Logging ────────────────────────────────────────────────────────────────
logging.basicConfig(
    filename='order_test.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

# ─── Client ─────────────────────────────────────────────────────────────────
print(">>> LIVE MODE – REAL MONEY – EXTREME CAUTION <<<")
print(">>> ORDER PLACEMENT TEST MODE ACTIVE <<<")
logger.critical("BOT STARTED IN LIVE MODE – ORDER TEST – REAL MONEY AT RISK")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol):
    try:
        positions = client.rest_api.position_information_v3(symbol=symbol)
    except Exception:
        try:
            positions = client.rest_api.position_information_v2(symbol=symbol)
        except Exception as e:
            logger.error(f"position query failed: {e}")
            return 0.0, 0.0

    long_qty = 0.0
    short_qty = 0.0

    if isinstance(positions, list):
        for pos in positions:
            if pos.get('symbol') == symbol:
                amt = float(pos.get('positionAmt', '0'))
                side = pos.get('positionSide', 'BOTH')
                if side in ('LONG', 'BOTH') and amt > 0:
                    long_qty = amt
                elif side in ('SHORT', 'BOTH') and amt < 0:
                    short_qty = amt

    return long_qty, short_qty


def is_long(qty: float) -> bool:
    return qty > 0.1


def is_short(qty: float) -> bool:
    return qty < -0.1


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        logger.info(f"Leverage set → {lev}x")
        print(f"Leverage set → {lev}x")
    except Exception as e:
        logger.warning(f"Leverage set failed (may already be set): {e}")


def market_order(symbol, side: str, quantity: float, position_side: str = None):
    if quantity < 0.1:
        print("Quantity too small – skipping")
        return None

    qty = round(quantity, 0)  # XRPUSDT usually integer steps
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qty,
        "newOrderRespType": "RESULT"
    }
    # Safe access to HEDGE_MODE (defaults to True if missing in config)
    if getattr(config, 'HEDGE_MODE', True) and position_side:
        params["positionSide"] = position_side.upper()

    try:
        order = client.rest_api.new_order(**params)
        msg = f"ORDER FILLED → {side.upper()} {qty} {symbol}"
        if position_side:
            msg += f" ({position_side})"
        msg += f"  ID: {order.get('orderId')}"
        print(msg)
        logger.info(msg)
        return order
    except Exception as e:
        logger.error(f"order failed: {e}")
        print(f"ORDER FAILED: {e}")
        return None


def close_side(symbol, side: str, qty: float):
    if abs(qty) < 0.1:
        return None
    order_side = "SELL" if side == "LONG" else "BUY"
    qty_abs = abs(qty)
    logger.info(f"Closing {side} → {order_side} {qty_abs}")
    print(f"Closing {side} → {order_side} {qty_abs}")
    # Use same safe HEDGE_MODE access
    return market_order(symbol, order_side, qty_abs, side if getattr(config, 'HEDGE_MODE', True) else None)


# ─── Test logic ─────────────────────────────────────────────────────────────

def run_test():
    long_qty, short_qty = get_position(SYMBOL)

    print(f"LONG: {long_qty:.2f} | SHORT: {short_qty:.2f}")

    # No position → force open LONG
    if not is_long(long_qty) and not is_short(short_qty):
        print("No position → forcing OPEN LONG")
        logger.info("Forcing OPEN LONG for test")
        order = market_order(SYMBOL, "BUY", TEST_QUANTITY, "LONG" if getattr(config, 'HEDGE_MODE', True) else None)
        if order:
            print("Open successful → waiting next cycle to close")
        return

    # Has LONG → force close
    if is_long(long_qty):
        print("Has LONG position → forcing CLOSE")
        logger.info("Forcing CLOSE LONG for test")
        close_side(SYMBOL, "LONG", long_qty)
        return

    print("Unexpected position state – skipping")
    logger.warning("Unexpected position state")


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting ORDER TEST bot → {SYMBOL}  LEVERAGE {LEVERAGE}")
    logger.critical(f"ORDER TEST STARTED – {SYMBOL} – REAL MONEY")

    set_leverage(SYMBOL, LEVERAGE)

    cycle = 0

    while TEST_MODE:
        cycle += 1
        now_utc = datetime.now(timezone.utc)  # ← fixed here (lowercase 'utc')
        print(f"\n--- Test cycle {cycle} at {now_utc.strftime('%Y-%m-%d %H:%M:%S UTC')} ---")
        try:
            run_test()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            logger.info("Stopped by user")
            break
        except Exception as e:
            logger.critical(f"MAIN LOOP ERROR: {e}", exc_info=True)
            print(f"CRITICAL ERROR: {e}")
            time.sleep(30)

        time.sleep(SLEEP_SECONDS)

    print("Test mode disabled (TEST_MODE = False). Bot stopped.")
