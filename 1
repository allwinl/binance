# bot.py
# Simple EMA vs Daily Open strategy – Binance USDS-M Futures
# Uses official binance-connector-python (UMFutures)
# All settings from config.py

import time
import logging
from datetime import datetime
import pandas as pd

try:
    from binance.um_futures import UMFutures
    from binance.error import ClientError
except ImportError:
    print("Install library first:")
    print("pip install binance-sdk-derivatives-trading-usds-futures")
    exit(1)

import config

# ─── Logging setup ────────────────────────────────────────────────
logging.basicConfig(
    filename='futures_bot.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ─── Client initialization ────────────────────────────────────────
kwargs = {
    "key": config.API_KEY,
    "secret": config.API_SECRET,
}

if config.BASE_URL:
    kwargs["base_url"] = config.BASE_URL
    print(">>> Using custom base URL (likely TESTNET) <<<")
    logger.info("Using custom base URL")
else:
    print(">>> LIVE PRODUCTION MODE – REAL MONEY RISK! <<<")
    logger.warning("LIVE PRODUCTION MODE ACTIVE")

if not config.RUN_LIVE:
    print("DRY RUN active – NO real orders will be placed!")

client = UMFutures(**kwargs)

# ─── Helper functions ─────────────────────────────────────────────

def get_klines(symbol, interval, limit=300):
    try:
        data = client.klines(symbol, interval, limit=limit)
        df = pd.DataFrame(data, columns=[
            'open_time', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'qv', 'trades', 'taker_base', 'taker_quote', 'ignore'
        ])
        df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
        for col in ['open', 'high', 'low', 'close']:
            df[col] = pd.to_numeric(df[col])
        return df
    except ClientError as e:
        logger.error(f"Klines error {e.error_code}: {e.error_message}")
        return None


def get_daily_open(symbol):
    try:
        data = client.klines(symbol, "1d", limit=2)
        return float(data[-1][1])  # open of current (possibly active) day
    except ClientError as e:
        logger.error(f"Daily open error {e.error_code}: {e.error_message}")
        return None


def get_position_amt(symbol):
    try:
        pos = client.get_position_risk(symbol=symbol)
        if pos and len(pos) > 0:
            return float(pos[0]['positionAmt'])
        return 0.0
    except ClientError as e:
        logger.error(f"Position error {e.error_code}: {e.error_message}")
        return 0.0


def get_usdt_available():
    try:
        acc = client.account()
        for asset in acc['assets']:
            if asset['asset'] == 'USDT':
                return float(asset['availableBalance'])
        return 0.0
    except ClientError as e:
        logger.error(f"Balance error {e.error_code}: {e.error_message}")
        return 0.0


def set_leverage(symbol, lev):
    try:
        client.change_leverage(symbol=symbol, leverage=lev)
        msg = f"Leverage set to {lev}x"
        print(msg)
        logger.info(msg)
    except ClientError as e:
        if e.error_code != -2015:  # ignore "already set" style errors if common
            logger.warning(f"Leverage set warning {e.error_code}: {e.error_message}")


def place_market_order(symbol, side, qty):
    if not config.RUN_LIVE:
        logger.info(f"DRY-RUN | would place {side} {qty:.3f} {symbol}")
        print(  f"DRY-RUN | would place {side} {qty:.3f} {symbol}")
        return None

    qty = round(qty, 3)  # BTCUSDT typical — improve with exchangeInfo later
    try:
        order = client.new_order(
            symbol=symbol,
            side=side.upper(),
            type="MARKET",
            quantity=qty
        )
        msg = f"ORDER EXECUTED → {side.upper()} {qty:.3f} {symbol} | ID: {order.get('orderId')}"
        print(msg)
        logger.info(msg)
        return order
    except ClientError as e:
        logger.error(f"Order failed {e.error_code}: {e.error_message}")
        print(f"Order failed {e.error_code}: {e.error_message}")
        return None


# ─── Strategy core ────────────────────────────────────────────────

def run_strategy():
    df = get_klines(config.SYMBOL, config.INTERVAL, limit=config.EMA_PERIOD * 3)
    if df is None or len(df) < config.EMA_PERIOD + 5:
        logger.warning("Not enough klines data")
        return

    df['ema'] = df['close'].ewm(span=config.EMA_PERIOD, adjust=False).mean()

    price_now = df['close'].iloc[-1]
    ema_now   = df['ema'].iloc[-1]
    daily_open = get_daily_open(config.SYMBOL)

    if daily_open is None:
        return

    ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    status = f"{ts} | Price {price_now:,.2f} | EMA{config.EMA_PERIOD} {ema_now:,.2f} | Open {daily_open:,.2f}"
    print(status)
    logger.info(status)

    pos_amt = get_position_amt(config.SYMBOL)
    dist_to_open = abs(price_now - daily_open) / daily_open
    usdt_avail = get_usdt_available()

    if usdt_avail < config.MIN_SAFE_BALANCE and pos_amt != 0:
        side = "SELL" if pos_amt > 0 else "BUY"
        logger.critical(f"EMERGENCY FLATTEN – low balance {usdt_avail:.2f}")
        place_market_order(config.SYMBOL, side, abs(pos_amt))
        return

    # Entry logic (flat position)
    if pos_amt == 0:
        if (price_now > ema_now and
            dist_to_open <= config.DAILY_OPEN_TOLERANCE * 1.8 and
            price_now >= daily_open * (1 - config.DAILY_OPEN_TOLERANCE)):
            qty = (usdt_avail * config.POSITION_PCT * config.LEVERAGE) / price_now
            if qty >= 0.001:
                logger.info(f"LONG signal → qty ≈ {qty:.3f}")
                place_market_order(config.SYMBOL, "BUY", qty)

        elif (price_now < ema_now and
              price_now <= daily_open * (1 - config.DAILY_OPEN_TOLERANCE)):
            qty = (usdt_avail * config.POSITION_PCT * config.LEVERAGE) / price_now
            if qty >= 0.001:
                logger.info(f"SHORT signal → qty ≈ {qty:.3f}")
                place_market_order(config.SYMBOL, "SELL", qty)

    # Exit logic
    elif pos_amt > 0 and price_now < ema_now * 0.988:  # ~1.2% below EMA
        logger.info("Close LONG triggered")
        place_market_order(config.SYMBOL, "SELL", abs(pos_amt))

    elif pos_amt < 0 and price_now > ema_now * 1.012:  # ~1.2% above EMA
        logger.info("Close SHORT triggered")
        place_market_order(config.SYMBOL, "BUY", abs(pos_amt))


# ─── Main loop ────────────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Bot starting → {config.SYMBOL} {config.INTERVAL} EMA({config.EMA_PERIOD})")
    logger.info(f"Bot started – live={config.RUN_LIVE} symbol={config.SYMBOL}")

    set_leverage(config.SYMBOL, config.LEVERAGE)

    while True:
        try:
            run_strategy()
        except KeyboardInterrupt:
            print("\nStopped by user.")
            logger.info("Stopped by user")
            break
        except Exception as e:
            logger.error(f"Unexpected loop error: {e}", exc_info=True)
            print(f"Error: {e}")

        time.sleep(config.SLEEP_SECONDS)
