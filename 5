# bot.py
# Binance USDS-M Futures Telegram bot – auto check every 30 seconds
# Fixed: all functions defined before use, no NameError
# /rem SYMBOL closes position + removes from monitoring
# Auto sets Isolated margin + 5x leverage on /add (skips if already set)

import asyncio
import logging
from datetime import datetime, timezone
import requests
import time
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Optional, Dict, Set
import pandas as pd
import math
from ta.trend import EMAIndicator   # pip install ta
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# ────────────────────────────────────────────────
# Load config
# ────────────────────────────────────────────────

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg = config.get("binance", {})
telegram_cfg = config.get("telegram", {})
trading_cfg = config.get("trading", {})

API_KEY        = binance_cfg.get("api_key")
API_SECRET     = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")

FIXED_LEVERAGE   = 5
FIXED_MARGIN_TYPE = "ISOLATED"
CHECK_INTERVAL_SECONDS = 30
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -10.0)

if not API_KEY or not API_SECRET or not TELEGRAM_TOKEN:
    print("ERROR: Missing api_key, api_secret or telegram token")
    exit(1)

BASE_URL = "https://fapi.binance.com"
HEADERS  = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ────────────────────────────────────────────────
# State
# ────────────────────────────────────────────────

monitored_symbols: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}  # "LONG", "SHORT" or None

# ────────────────────────────────────────────────
# Binance helpers (defined BEFORE any call)
# ────────────────────────────────────────────────

def signed_request(method: str, endpoint: str, params: Dict = None) -> Dict:
    if params is None:
        params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000

    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()

        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error {data['code']}: {data.get('msg')} | URL: {url}")
        return data
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error {e.response.status_code}: {e.response.text} | URL: {url}")
        return {"error": str(e), "status_code": e.response.status_code}
    except Exception as e:
        logger.error(f"Request failed: {e} | URL: {url}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None:
        params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed: {e}")
        return []

def set_leverage_and_margin(symbol: str) -> bool:
    # Check current settings first
    pos_data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if not isinstance(pos_data, list) or not pos_data:
        logger.warning(f"Cannot check current settings for {symbol}")
        return False

    current_leverage = int(pos_data[0].get("leverage", 0))
    current_margin = "ISOLATED" if pos_data[0].get("isolated", False) else "CROSSED"

    if current_leverage == FIXED_LEVERAGE and current_margin == FIXED_MARGIN_TYPE:
        logger.info(f"{symbol} already at {FIXED_LEVERAGE}x + {FIXED_MARGIN_TYPE} – skip set")
        return True

    success = True

    if current_leverage != FIXED_LEVERAGE:
        lev_resp = signed_request("POST", "/fapi/v1/leverage", {
            "symbol": symbol,
            "leverage": FIXED_LEVERAGE
        })
        if "code" in lev_resp and lev_resp["code"] < 0:
            logger.error(f"Failed leverage {symbol}: {lev_resp}")
            success = False

    if current_margin != FIXED_MARGIN_TYPE:
        margin_resp = signed_request("POST", "/fapi/v1/marginType", {
            "symbol": symbol,
            "marginType": FIXED_MARGIN_TYPE
        })
        if "code" in margin_resp and margin_resp["code"] < 0:
            logger.error(f"Failed margin type {symbol}: {margin_resp}")
            success = False

    if success:
        logger.info(f"Verified/set {symbol}: {FIXED_LEVERAGE}x + {FIXED_MARGIN_TYPE}")
    return success

def get_current_position_data(symbol: str) -> dict:
    params = {"symbol": symbol}
    data = signed_request("GET", "/fapi/v2/positionRisk", params)
    if isinstance(data, list) and data:
        pos = data[0]
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        amt = float(pos.get("positionAmt", "0"))
        real_side = "LONG" if amt > 0 else "SHORT"

    current = symbol_position_state.get(symbol, None)
    if real_side != current:
        logger.info(f"Sync {symbol}: {current or 'None'} → {real_side or 'None'}")
        symbol_position_state[symbol] = real_side

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            if s.get("contractType") == "PERPETUAL" and s.get("status") == "TRADING":
                return True
    return False

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    if isinstance(data, dict) and "markPrice" in data:
        return float(data["markPrice"])
    logger.warning(f"No markPrice for {symbol}")
    return 0.0

def get_klines(symbol: str, interval: str, limit: int = 100) -> list:
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines failed for {symbol} {interval}: {e}")
        return []

def calculate_safe_quantity(symbol: str) -> float:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict):
        logger.warning(f"No exchangeInfo for {symbol}")
        return 0.001

    min_notional = 5.0
    step_size = 0.1
    min_qty = 0.1
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    min_qty = float(f["minQty"])
                    step_size = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    min_notional = float(f.get("notional", 5.0))
            break

    price = get_current_price(symbol)
    if price <= 0:
        logger.warning(f"No price for {symbol}")
        return 0.001

    target = min_notional * 1.05
    raw_qty = target / price
    steps = math.ceil(raw_qty / step_size)
    qty = max(steps * step_size, min_qty)
    logger.info(f"[{symbol}] qty = {qty:.6f} (~{target:.2f} USDT)")
    return round(qty, 6)

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> Dict:
    if qty <= 0:
        return {"error": "Invalid quantity"}

    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")

    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"

    logger.info(f"Order: {side.upper()} {qstr} {symbol} reduceOnly={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def close_position(symbol: str) -> bool:
    pos = get_current_position_data(symbol)
    if not pos:
        logger.info(f"No position to close on {symbol}")
        return True

    amt = float(pos.get("positionAmt", "0"))
    side = "SELL" if amt > 0 else "BUY"
    qty = abs(amt)
    resp = place_market_order(symbol, side, qty, reduce_only=True)

    if resp.get("status") in ("NEW", "FILLED"):
        symbol_position_state[symbol] = None
        logger.info(f"Closed position on {symbol}")
        return True
    else:
        logger.error(f"Close failed on {symbol}: {resp}")
        return False

def close_all_positions():
    positions = signed_request("GET", "/fapi/v2/positionRisk")
    if not isinstance(positions, list):
        return []

    closed = []
    for pos in positions:
        amt = float(pos.get("positionAmt", "0"))
        if abs(amt) <= POSITION_TOLERANCE:
            continue

        sym = pos["symbol"]
        if close_position(sym):
            closed.append(sym)

    return closed

# ────────────────────────────────────────────────
# Telegram Handlers
# ────────────────────────────────────────────────

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Futures EMA-3 bot\n\n"
        "• Auto-check every 30s\n"
        "• Auto-reverse on opposite signal\n"
        "• Loss-cut if PnL < threshold\n"
        "• /rem SYMBOL closes position + removes\n"
        "• Auto Isolated + 5x on /add\n\n"
        "Commands:\n"
        "/add SYMBOL\n"
        "/rem SYMBOL\n"
        "/rem or /reset\n"
        "/test SYMBOL\n"
    )

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add XRPUSDT")
        return

    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT perpetual symbols")
        return

    if symbol_is_valid_perp(sym):
        if sym in monitored_symbols:
            await update.message.reply_text(f"{sym} already monitored")
        else:
            if set_leverage_and_margin(sym):
                monitored_symbols.add(sym)
                symbol_position_state.setdefault(sym, None)
                await update.message.reply_text(
                    f"Added {sym} (Isolated + 5x)\n"
                    f"Current list: {', '.join(sorted(monitored_symbols)) or 'empty'}"
                )
            else:
                await update.message.reply_text(f"Failed to set Isolated/5x for {sym}")
    else:
        await update.message.reply_text(f"{sym} not valid or not trading")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        old_list = sorted(monitored_symbols)
        monitored_symbols.clear()
        symbol_position_state.clear()

        closed = close_all_positions()

        text = "Full reset complete.\n"
        if old_list:
            text += f"Removed symbols: {', '.join(old_list)}\n"
        if closed:
            text += f"Closed positions on: {', '.join(closed)}"
        else:
            text += "No open positions found."

        await update.message.reply_text(text)
        return

    sym = context.args[0].strip().upper()
    if sym in monitored_symbols:
        closed = close_position(sym)
        monitored_symbols.remove(sym)
        symbol_position_state.pop(sym, None)

        msg = f"Removed {sym} from monitoring"
        if closed:
            msg += " and closed any open position"
        else:
            msg += " (no open position found)"

        msg += f"\nCurrent list: {', '.join(sorted(monitored_symbols)) or 'empty'}"
        await update.message.reply_text(msg)
    else:
        await update.message.reply_text(f"{sym} not in monitoring list")

async def cmd_test(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /test XRPUSDT")
        return

    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT symbols")
        return

    if not symbol_is_valid_perp(sym):
        await update.message.reply_text(f"{sym} not valid perpetual futures pair")
        return

    qty = calculate_safe_quantity(sym)
    if qty <= 0:
        await update.message.reply_text("Cannot calculate quantity")
        return

    await update.message.reply_text(
        f"Test cycle {sym}\n"
        f"Quantity: {qty:.6f}\n"
        "LONG → close → SHORT → close ...\n"
    )

    await update.message.reply_text("1/4 Opening LONG...")
    open_long = place_market_order(sym, "BUY", qty)
    await update.message.reply_text(f"Open LONG: {open_long.get('status', 'unknown')}")

    await asyncio.sleep(4)

    await update.message.reply_text("2/4 Closing LONG...")
    close_long = place_market_order(sym, "SELL", qty, reduce_only=True)
    await update.message.reply_text(f"Close LONG: {close_long.get('status', 'unknown')}")

    await asyncio.sleep(3)

    await update.message.reply_text("3/4 Opening SHORT...")
    open_short = place_market_order(sym, "SELL", qty)
    await update.message.reply_text(f"Open SHORT: {open_short.get('status', 'unknown')}")

    await asyncio.sleep(4)

    await update.message.reply_text("4/4 Closing SHORT...")
    close_short = place_market_order(sym, "BUY", qty, reduce_only=True)
    await update.message.reply_text(f"Close SHORT: {close_short.get('status', 'unknown')}")

    await update.message.reply_text("Test cycle finished.")

async def handle_symbol_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text.strip().upper()
    if text.startswith('/') or len(text) < 4 or not text.endswith("USDT"):
        return

    symbol = text

    if symbol not in monitored_symbols:
        await update.message.reply_text(f"{symbol} not monitored. Use /add first.")
        return

    current_side = symbol_position_state.get(symbol, None)
    if current_side is not None:
        await update.message.reply_text(f"Already {current_side} on {symbol} – skipped")
        return

    await update.message.reply_text(f"Manual check: {symbol}")

    klines_1m = get_klines(symbol, "1m", 50)
    if not klines_1m or len(klines_1m) < 5:
        await update.message.reply_text("Not enough 1m data")
        return

    klines_1d = get_klines(symbol, "1d", 2)
    if not klines_1d:
        await update.message.reply_text("Failed to get 1d data")
        return

    today_open = float(klines_1d[-1][1])
    closes = [float(k[4]) for k in klines_1m]

    df = pd.DataFrame({"close": closes})
    ema_indicator = EMAIndicator(close=df["close"], window=5)
    ema_value = ema_indicator.ema_indicator().iloc[-2]
    ema_value2 = ema_indicator.ema_indicator().iloc[-3]
    
    qty = calculate_safe_quantity(symbol)

    msg = (
        f"**Manual check {symbol}**\n"
        f"1d open: {today_open:.4f}\n"
        f"EMA-3: {ema_value:.4f}\n"
        f"Quantity: {qty:.6f}\n"
    )

    if ema_value > today_open and ema_value2 < today_open:
        msg += "→ opening LONG"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "BUY", qty)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "LONG"
    elif ema_value < today_open and ema_value2 > today_open:
        msg += "→ opening SHORT"
        await update.message.reply_text(msg)
        resp = place_market_order(symbol, "SELL", qty)
        await update.message.reply_text(f"Result:\n{resp}")
        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
            symbol_position_state[symbol] = "SHORT"
    else:
        msg += "→ no action"
        await update.message.reply_text(msg)

# ────────────────────────────────────────────────
# Auto-check loop
# ────────────────────────────────────────────────

async def auto_check_symbols(app: Application) -> None:
    while True:
        if monitored_symbols:
            logger.info(f"Auto-checking {len(monitored_symbols)} symbols...")
            for symbol in list(monitored_symbols):
                try:
                    sync_position_state(symbol)
                    current_side = symbol_position_state.get(symbol, None)

                    pos_data = get_current_position_data(symbol)
                    if pos_data:
                        pnl = float(pos_data.get("unRealizedProfit", 0))
                        if pnl < MAX_ALLOWED_LOSS_USDT:
                            logger.warning(f"[{symbol}] LOSS CUT! PnL {pnl:.2f}")
                            side = "SELL" if current_side == "LONG" else "BUY"
                            qty = abs(float(pos_data["positionAmt"]))
                            close_resp = place_market_order(symbol, side, qty, reduce_only=True)
                            if close_resp.get("status") in ("NEW", "FILLED"):
                                symbol_position_state[symbol] = None
                            continue

                    klines_1m = get_klines(symbol, "1m", 50)
                    if not klines_1m or len(klines_1m) < 3:
                        continue

                    klines_1d = get_klines(symbol, "1d", 2)
                    if not klines_1d:
                        continue

                    today_open = float(klines_1d[-1][1])
                    closes = [float(k[4]) for k in klines_1m]

                    df = pd.DataFrame({"close": closes})
                    ema_indicator = EMAIndicator(close=df["close"], window=3)
                    ema_value = ema_indicator.ema_indicator().iloc[-1]

                    logger.info(
                        f"[{symbol}] 1d open: {today_open:.4f} | EMA-3: {ema_value:.4f} | pos: {current_side or 'None'}"
                    )

                    should_long  = ema_value > today_open
                    should_short = ema_value < today_open

                    qty = calculate_safe_quantity(symbol)

                    if current_side is None:
                        if should_long:
                            logger.info(f"→ {symbol} open LONG")
                            resp = place_market_order(symbol, "BUY", qty)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"
                        elif should_short:
                            logger.info(f"→ {symbol} open SHORT")
                            resp = place_market_order(symbol, "SELL", qty)
                            if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"

                    elif current_side == "LONG" and should_short:
                        logger.info(f"→ {symbol} reverse LONG → SHORT")
                        close_resp = place_market_order(symbol, "SELL", qty, reduce_only=True)
                        if close_resp.get("status") in ("NEW", "FILLED"):
                            open_resp = place_market_order(symbol, "SELL", qty)
                            if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "SHORT"

                    elif current_side == "SHORT" and should_long:
                        logger.info(f"→ {symbol} reverse SHORT → LONG")
                        close_resp = place_market_order(symbol, "BUY", qty, reduce_only=True)
                        if close_resp.get("status") in ("NEW", "FILLED"):
                            open_resp = place_market_order(symbol, "BUY", qty)
                            if open_resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                                symbol_position_state[symbol] = "LONG"

                except Exception as e:
                    logger.error(f"Error checking {symbol}: {e}")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ────────────────────────────────────────────────
# Startup hook
# ────────────────────────────────────────────────

async def on_startup(app: Application) -> None:
    asyncio.create_task(auto_check_symbols(app))
    logger.info(f"Auto-check started – interval {CHECK_INTERVAL_SECONDS}s")

# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────

def main() -> None:
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("add", cmd_add))
    app.add_handler(CommandHandler("rem", cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))
    app.add_handler(CommandHandler("test", cmd_test))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_symbol_message))

    app.post_init = on_startup

    print("Bot starting...")
    print("Monitored:", monitored_symbols)
    print("States:", symbol_position_state)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
