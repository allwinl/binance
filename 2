# bot.py
# Binance USDS-M Futures – Simple LONG ↔ SHORT flip test with fill verification
# XRPUSDT – VERY SMALL SIZE – REAL MONEY – EXTREME CAUTION

import time
import logging
from datetime import datetime, timezone

try:
    from binance_sdk_derivatives_trading_usds_futures.derivatives_trading_usds_futures import DerivativesTradingUsdsFutures
    from binance_sdk_derivatives_trading_usds_futures.rest_api.models import NewOrderSideEnum
    from binance_common.configuration import ConfigurationRestAPI
    from binance_common.constants import DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
except ImportError:
    print("Missing SDK – pip install binance-sdk-derivatives-trading-usds-futures binance-common")
    exit(1)

import config  # needs API_KEY, API_SECRET

# ─── Config ─────────────────────────────────────────────────────────────────
RUN_LOOP          = True
SYMBOL            = "XRPUSDT"
QUANTITY          = 5.0
LEVERAGE          = 5
SLEEP_AFTER_CYCLE = 20
ORDER_WAIT        = 12.0   # increased slightly

logging.basicConfig(
    filename='flip_test_debug.log',
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-5s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S UTC'
)
logger = logging.getLogger(__name__)

print(">>> LIVE TRADING – REAL MONEY – EXTREME CAUTION <<<")
print(f">>> Flip: LONG ↔ SHORT | {SYMBOL} @ {LEVERAGE}x | qty {QUANTITY} <<<")
logger.info("BOT STARTED – LONG/SHORT FLIP WITH FILL CHECK")

configuration = ConfigurationRestAPI(
    api_key=config.API_KEY,
    api_secret=config.API_SECRET,
    base_path=DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL
)
client = DerivativesTradingUsdsFutures(config_rest_api=configuration)

# ─── Helpers ────────────────────────────────────────────────────────────────

def get_position(symbol=None):  # symbol=None → get all positions
    qty = 0.0
    used_endpoint = "none"
    all_raw = []

    for ep in ['position_information_v3', 'position_information_v2']:
        try:
            method = getattr(client.rest_api, ep)
            if symbol:
                resp = method(symbol=symbol)
            else:
                resp = method()  # all positions
            data = resp.data() if hasattr(resp, 'data') and callable(getattr(resp, 'data')) else resp

            all_raw.append((ep, data))

            if isinstance(data, list):
                if symbol:
                    for pos in data:
                        if pos.get('symbol') == symbol:
                            amt_str = pos.get('positionAmt', '0')
                            qty = float(amt_str)
                            used_endpoint = ep
                            print(f"Found {symbol} in {ep}: positionAmt = {amt_str} | side={pos.get('positionSide')}")
                            break
                else:
                    # For all positions: scan for symbol
                    for pos in data:
                        if pos.get('symbol') == SYMBOL:
                            amt_str = pos.get('positionAmt', '0')
                            qty = float(amt_str)
                            used_endpoint = ep + " (all)"
                            print(f"Found {SYMBOL} in all positions ({ep}): positionAmt = {amt_str}")
                            break
                    print(f"All positions count: {len(data)}")
                    if len(data) > 0:
                        print("First few raw: ", data[:2])  # debug

            if qty != 0.0:
                break
        except Exception as e:
            print(f"{ep} error: {e}")
            logger.error(f"{ep} error: {e}")

    if qty == 0.0 and all_raw:
        print("Position 0 – raw responses (last tried):")
        for ep, d in all_raw[-1:]:
            print(f"  {ep}: type={type(d)}, len={len(d) if isinstance(d, list) else 'N/A'}, sample={d[:1] if isinstance(d, list) else d}")

    print(f"Detected position: {qty:+.1f} (endpoint: {used_endpoint})")
    return qty


def set_leverage(symbol, lev):
    try:
        client.rest_api.change_initial_leverage(symbol=symbol, leverage=lev)
        print(f"Leverage set: {lev}x")
    except Exception as e:
        print(f"Leverage warning: {e}")


def send_market_order(symbol, side_enum, qty_float: float):
    qty = round(abs(qty_float), 0)
    if qty < 1:
        print("Qty too small – skip")
        return False

    params = {
        "symbol": symbol,
        "side": side_enum.value,
        "type": "MARKET",
        "quantity": qty,
    }

    try:
        response = client.rest_api.new_order(**params)
        data = response.data() if hasattr(response, 'data') and callable(getattr(response, 'data')) else response

        order_id = data.get('orderId') if isinstance(data, dict) else getattr(data, 'orderId', None)
        client_order_id = data.get('clientOrderId') if isinstance(data, dict) else getattr(data, 'clientOrderId', None)
        print(f"ORDER PLACED → {side_enum.name} {qty} {symbol} | ID: {order_id or client_order_id or 'N/A'}")

        if not order_id:
            print("No order ID – placement likely failed")
            return False

        # Check status
        time.sleep(2)  # brief wait
        try:
            status_method = getattr(client.rest_api, 'order_information', None) or getattr(client.rest_api, 'get_order', None)
            if status_method:
                status_resp = status_method(symbol=symbol, orderId=order_id)
                status_data = status_resp.data() if hasattr(status_resp, 'data') else status_resp
                status = status_data.get('status') if isinstance(status_data, dict) else getattr(status_data, 'status', 'UNKNOWN')
                print(f"Order status: {status}")
                if status != 'FILLED':
                    print(f"!!! NOT FILLED ({status}) – check Binance app/web for rejection reason (margin? min notional? permissions?)")
                    return False
            else:
                print("No order_information method in SDK – manual check needed")
        except Exception as e:
            print(f"Status check failed: {e} (continue anyway)")

        print(f"Waiting {ORDER_WAIT}s for position update...")
        time.sleep(ORDER_WAIT)
        return True

    except Exception as e:
        print(f"ORDER PLACEMENT FAILED: {e}")
        logger.error(f"Order fail: {e}")
        return False


# ─── Main ───────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    set_leverage(SYMBOL, LEVERAGE)

    # Optional: check position mode if SDK supports
    try:
        mode_resp = client.rest_api.position_mode()  # or dual_side_position
        mode_data = mode_resp.data() if hasattr(mode_resp, 'data') else mode_resp
        dual = mode_data.get('dualSidePosition', False)
        print(f"Position mode: {'Hedge (dual)' if dual else 'One-way'}")
    except:
        print("Could not check position mode – assume One-way (common). Check in Binance app: Futures > Preferences.")

    cycle = 0
    while RUN_LOOP:
        cycle += 1
        now = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
        print(f"\n=== Cycle {cycle} @ {now} ===")

        pos_qty = get_position(SYMBOL)  # or get_position() for all

        success = False
        if pos_qty > 0:
            print(f"LONG open → flip to SHORT (SELL {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["SELL"], QUANTITY)
        elif pos_qty < 0:
            print(f"SHORT open → flip to LONG (BUY {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)
        else:
            print(f"Flat → start LONG (BUY {QUANTITY})")
            success = send_market_order(SYMBOL, NewOrderSideEnum["BUY"], QUANTITY)

        # Verify flip happened
        time.sleep(2)
        new_qty = get_position(SYMBOL)
        print(f"After order: position {new_qty:+.1f}")

        if not success or new_qty == pos_qty:
            print("!!! No change detected – STOPPING to avoid accumulation. Check Binance manually.")
            break

        time.sleep(SLEEP_AFTER_CYCLE)

    print("Stopped.")
