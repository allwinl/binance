# bot.py
# Binance USDS-M Futures ‚Äì selected perpetual USDT pairs (Telegram controlled)
# Strategy:
#   - 5m candles
#   - HMA(9) on close
#   - RSI(14) applied to HMA values
#   - SMA(14) on that RSI        ‚Üê note: you had rolling(5) in code ‚Üí changed comment
#   - LONG:  RSI crosses ABOVE SMA
#   - SHORT: RSI crosses BELOW SMA
#   - Exit/reverse:      close crosses back over HMA
#   - TP: 0.6% limit
#   - SL: 0.9% limit     ‚Üê new
#   - Telegram notify on entry / tp / sl / reverse / loss cut
#   - Check every 60 seconds
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import time
import logging
import requests
import hmac
import hashlib
import yaml
from urllib.parse import urlencode
from typing import Dict, Set, Optional
import pandas as pd
import numpy as np
import math
import asyncio
from ta.trend import WMAIndicator
from ta.momentum import RSIIndicator

from telegram import Update, Bot
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Config
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

try:
    with open("config.yaml", "r") as f:
        config = yaml.safe_load(f)
except FileNotFoundError:
    print("ERROR: config.yaml not found")
    exit(1)

binance_cfg  = config.get("binance",  {})
telegram_cfg = config.get("telegram", {})
trading_cfg  = config.get("trading",  {})

API_KEY    = binance_cfg.get("api_key")
API_SECRET = binance_cfg.get("api_secret")
TELEGRAM_TOKEN = telegram_cfg.get("token")
TELEGRAM_CHAT_ID = telegram_cfg.get("chat_id")          # ‚Üê add this to config.yaml !

USE_TESTNET = trading_cfg.get("use_testnet", True)

if USE_TESTNET:
    BASE_URL = "https://testnet.binancefuture.com"
    print("=== TESTNET MODE ===")
else:
    BASE_URL = "https://fapi.binance.com"
    print("=== MAINNET ‚Äì REAL MONEY ===")

FIXED_LEVERAGE   = 5
FIXED_MARGIN_TYPE = "ISOLATED"
CHECK_INTERVAL_SECONDS = 60
POSITION_TOLERANCE     = 1e-6
MAX_ALLOWED_LOSS_USDT  = trading_cfg.get("max_allowed_loss_usdt", -10.0)
TAKE_PROFIT_PCT        = 0.006   # 0.6%
STOP_LOSS_PCT          = 0.009   # 0.9%  ‚Üê new

if not API_KEY or not API_SECRET or not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
    print("ERROR: Missing keys/token/chat_id")
    exit(1)

HEADERS = {"X-MBX-APIKEY": API_KEY}

logging.basicConfig(
    format='%(asctime)s  %(levelname)-8s  %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# State
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

monitored_symbols: Set[str] = set()
configured: Set[str] = set()
symbol_position_state: Dict[str, Optional[str]] = {}
symbol_entry_price: Dict[str, Optional[float]] = {}
symbol_tp_order_id: Dict[str, Optional[int]] = {}
symbol_sl_order_id: Dict[str, Optional[int]] = {}     # ‚Üê new

_price_precision_cache: Dict[str, int] = {}

# Telegram bot instance for notifications
telegram_bot = Bot(token=TELEGRAM_TOKEN)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram notifications
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def send_telegram(msg: str):
    try:
        await telegram_bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=msg,
            disable_notification=False
        )
    except Exception as e:
        logger.error(f"Telegram send failed: {e}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Binance helpers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def signed_request(method: str, endpoint: str, params: Dict = None) -> dict:
    if params is None: params = {}
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000
    qs = urlencode(sorted(params.items()))
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    url = f"{BASE_URL}{endpoint}?{qs}&signature={sig}"

    try:
        if method.upper() == "GET":
            r = requests.get(url, headers=HEADERS, timeout=10)
        elif method.upper() == "POST":
            r = requests.post(url, headers=HEADERS, timeout=10)
        elif method.upper() == "DELETE":
            r = requests.delete(url, headers=HEADERS, timeout=10)
        else:
            raise ValueError("Bad method")

        r.raise_for_status()
        data = r.json()
        if isinstance(data, dict) and "code" in data and data["code"] < 0:
            logger.error(f"API error: {data.get('msg')}")
        return data
    except Exception as e:
        logger.error(f"Request failed: {e}")
        return {"error": str(e)}

def public_get(endpoint: str, params: Dict = None) -> list | dict:
    if params is None: params = {}
    try:
        r = requests.get(f"{BASE_URL}{endpoint}", params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Public GET failed: {e}")
        return []

def symbol_is_valid_perp(symbol: str) -> bool:
    data = public_get("/fapi/v1/exchangeInfo")
    if not isinstance(data, dict): return False
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            return s.get("contractType") == "PERPETUAL" and s.get("status") == "TRADING"
    return False

def get_price_precision(symbol: str) -> int:
    if symbol in _price_precision_cache:
        return _price_precision_cache[symbol]
    data = public_get("/fapi/v1/exchangeInfo")
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "PRICE_FILTER":
                    tick = float(f.get("tickSize", "0.0001"))
                    if tick > 0:
                        prec = max(0, -int(math.log10(tick)))
                        _price_precision_cache[symbol] = prec
                        return prec
    _price_precision_cache[symbol] = 4
    return 4

def ensure_leverage_and_margin(symbol: str) -> bool:
    if symbol in configured: return True
    pos_data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if not isinstance(pos_data, list) or not pos_data: return False
    pos = pos_data[0]
    lev_ok = int(pos.get("leverage", 0)) == FIXED_LEVERAGE
    margin_ok = pos.get("isolated", False) == (FIXED_MARGIN_TYPE == "ISOLATED")

    success = True
    if not lev_ok:
        r = signed_request("POST", "/fapi/v1/leverage", {"symbol": symbol, "leverage": FIXED_LEVERAGE})
        if "code" in r and r["code"] < 0: success = False
    if not margin_ok:
        r = signed_request("POST", "/fapi/v1/marginType", {"symbol": symbol, "marginType": FIXED_MARGIN_TYPE})
        if "code" in r and r["code"] < 0: success = False
    if success:
        configured.add(symbol)
        logger.info(f"{symbol}: {FIXED_LEVERAGE}x Isolated set")
    return success

def get_current_position_data(symbol: str) -> dict:
    data = signed_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol})
    if isinstance(data, list) and data:
        pos = data[0]
        if abs(float(pos.get("positionAmt", "0"))) > POSITION_TOLERANCE:
            return pos
    return {}

def sync_position_state(symbol: str) -> None:
    pos = get_current_position_data(symbol)
    real_side = None
    if pos:
        amt = float(pos.get("positionAmt", "0"))
        real_side = "LONG" if amt > 0 else "SHORT"
    current = symbol_position_state.get(symbol)
    if real_side != current:
        logger.info(f"Sync {symbol}: {current or 'None'} ‚Üí {real_side or 'None'}")
        if symbol in symbol_tp_order_id:
            cancel_take_profit(symbol)
        if symbol in symbol_sl_order_id:          # ‚Üê new
            cancel_stop_loss(symbol)
        symbol_position_state[symbol] = real_side
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        symbol_sl_order_id[symbol] = None

def get_current_price(symbol: str) -> float:
    data = public_get("/fapi/v1/premiumIndex", {"symbol": symbol})
    return float(data.get("markPrice", 0)) if isinstance(data, dict) else 0.0

def get_klines(symbol: str, interval: str, limit: int = 200) -> list:
    try:
        r = requests.get(f"{BASE_URL}/fapi/v1/klines", params={
            "symbol": symbol, "interval": interval, "limit": limit
        }, timeout=12)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logger.error(f"Klines {symbol} {interval}: {e}")
        return []

def calculate_safe_quantity(symbol: str) -> float:
    data = public_get("/fapi/v1/exchangeInfo")
    min_notional = 5.0
    step_size = 0.001
    min_qty = 0.001
    for s in data.get("symbols", []):
        if s["symbol"] == symbol:
            for f in s.get("filters", []):
                if f["filterType"] == "LOT_SIZE":
                    min_qty = float(f["minQty"])
                    step_size = float(f["stepSize"])
                if f["filterType"] == "MIN_NOTIONAL":
                    min_notional = float(f.get("notional", 5.0))
            break
    price = get_current_price(symbol)
    if price <= 0: return 0.001
    target_usdt = min_notional * 1.1
    raw_qty = target_usdt / price
    steps = math.ceil(raw_qty / step_size)
    qty = max(steps * step_size, min_qty)
    return round(qty, 6)

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False) -> dict:
    if qty <= 0: return {"error": "Invalid qty"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": side.upper(),
        "type": "MARKET",
        "quantity": qstr,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    logger.info(f"ORDER {side.upper()} {qstr} {symbol} reduce={reduce_only}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_take_profit_order(symbol: str, side: str, qty: float, price: float) -> dict:
    if price <= 0 or qty <= 0: return {"error": "Invalid TP"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    prec = get_price_precision(symbol)
    pstr = f"{price:.{prec}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    logger.info(f"TP {params['side']} {qstr} @ {pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def place_stop_loss_order(symbol: str, side: str, qty: float, price: float) -> dict:     # ‚Üê new
    if price <= 0 or qty <= 0: return {"error": "Invalid SL"}
    qstr = f"{qty:.6f}".rstrip("0").rstrip(".")
    prec = get_price_precision(symbol)
    pstr = f"{price:.{prec}f}".rstrip("0").rstrip(".")
    params = {
        "symbol": symbol,
        "side": "SELL" if side == "LONG" else "BUY",
        "type": "LIMIT",
        "timeInForce": "GTC",
        "quantity": qstr,
        "price": pstr,
        "reduceOnly": "true",
    }
    logger.info(f"SL {params['side']} {qstr} @ {pstr} {symbol}")
    return signed_request("POST", "/fapi/v1/order", params)

def cancel_take_profit(symbol: str) -> bool:
    order_id = symbol_tp_order_id.get(symbol)
    if not order_id: return True
    resp = signed_request("DELETE", "/fapi/v1/order", {"symbol": symbol, "orderId": order_id})
    success = "orderId" in resp or (isinstance(resp, dict) and resp.get("code") in (-2011, -2013))
    if success:
        symbol_tp_order_id[symbol] = None
    return success

def cancel_stop_loss(symbol: str) -> bool:       # ‚Üê new
    order_id = symbol_sl_order_id.get(symbol)
    if not order_id: return True
    resp = signed_request("DELETE", "/fapi/v1/order", {"symbol": symbol, "orderId": order_id})
    success = "orderId" in resp or (isinstance(resp, dict) and resp.get("code") in (-2011, -2013))
    if success:
        symbol_sl_order_id[symbol] = None
    return success

def close_position(symbol: str, reason: str = "manual") -> bool:
    pos = get_current_position_data(symbol)
    if not pos: return True
    amt = float(pos.get("positionAmt", "0"))
    side = "SELL" if amt > 0 else "BUY"
    qty = abs(amt)
    resp = place_market_order(symbol, side, qty, reduce_only=True)
    success = resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED")
    if success:
        cancel_take_profit(symbol)
        cancel_stop_loss(symbol)
        symbol_position_state[symbol] = None
        symbol_entry_price[symbol] = None
        symbol_tp_order_id[symbol] = None
        symbol_sl_order_id[symbol] = None
        logger.info(f"Closed {symbol} ({reason})")
        asyncio.create_task(send_telegram(f"Position closed ({reason}): {symbol}"))
    return success

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HMA
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def hull_moving_average(series: pd.Series, period: int = 9) -> pd.Series:
    half = int(period / 2)
    sqrt_p = int(np.sqrt(period))
    wma_half = WMAIndicator(series, window=half).wma()
    wma_full = WMAIndicator(series, window=period).wma()
    raw = 2 * wma_half - wma_full
    hma = WMAIndicator(raw, window=sqrt_p).wma()
    return hma

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Telegram commands
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "RSI-on-HMA(9) crossover bot ‚Äì 5m timeframe\n\n"
        "LONG: RSI(14 on HMA) crosses ABOVE SMA(14 on RSI)\n"
        "SHORT: RSI crosses BELOW SMA\n"
        "TP: 0.6%  |  SL: 0.9%\n"
        "Reverse on close ‚Üî HMA cross\n\n"
        "Commands:\n"
        "/add SYMBOL\n"
        "/rem SYMBOL    or    /reset (all + close)\n"
        "/list\n"
    )

async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Usage: /add BTCUSDT")
        return
    sym = context.args[0].strip().upper()
    if not sym.endswith("USDT"):
        await update.message.reply_text("Only USDT perps")
        return
    if not symbol_is_valid_perp(sym):
        await update.message.reply_text(f"{sym} invalid/not trading")
        return
    if sym in monitored_symbols:
        await update.message.reply_text(f"{sym} already monitored")
        return
    if ensure_leverage_and_margin(sym):
        monitored_symbols.add(sym)
        symbol_position_state[sym] = None
        await update.message.reply_text(f"Added {sym} (5√ó Isolated)\nMonitored: {', '.join(sorted(monitored_symbols)) or 'none'}")
    else:
        await update.message.reply_text(f"Failed to set leverage/margin {sym}")

async def cmd_rem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        closed = [sym for sym in list(monitored_symbols) if close_position(sym, "reset")]
        old = sorted(monitored_symbols)
        monitored_symbols.clear()
        symbol_position_state.clear()
        symbol_entry_price.clear()
        symbol_tp_order_id.clear()
        symbol_sl_order_id.clear()
        configured.clear()
        text = "Full reset.\n"
        if old: text += f"Removed: {', '.join(old)}\n"
        if closed: text += f"Closed: {', '.join(closed)}"
        else: text += "No positions open."
        await update.message.reply_text(text)
        return

    sym = context.args[0].strip().upper()
    if sym not in monitored_symbols:
        await update.message.reply_text(f"{sym} not monitored")
        return
    closed = close_position(sym, "manual remove")
    monitored_symbols.remove(sym)
    symbol_position_state.pop(sym, None)
    symbol_entry_price.pop(sym, None)
    symbol_tp_order_id.pop(sym, None)
    symbol_sl_order_id.pop(sym, None)
    configured.discard(sym)
    msg = f"Removed {sym}"
    if closed: msg += " + closed position"
    await update.message.reply_text(f"{msg}\nNow: {', '.join(sorted(monitored_symbols)) or 'none'}")

async def cmd_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not monitored_symbols:
        await update.message.reply_text("No symbols monitored.")
        return
    lines = ["Monitored:"]
    for sym in sorted(monitored_symbols):
        side = symbol_position_state.get(sym, "‚Äî")
        lines.append(f"  {sym:10}  {side}")
    await update.message.reply_text("\n".join(lines))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Trading loop
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def trading_loop(_: Application) -> None:
    logger.info(f"Started ‚Äì 5m RSI-on-HMA ‚Äì TP {TAKE_PROFIT_PCT*100:.1f}% / SL {STOP_LOSS_PCT*100:.1f}% ‚Äì {len(monitored_symbols)} symbols")
    while True:
        if not monitored_symbols:
            await asyncio.sleep(CHECK_INTERVAL_SECONDS)
            continue

        for symbol in list(monitored_symbols):
            try:
                sync_position_state(symbol)
                current_side = symbol_position_state.get(symbol)

                pos = get_current_position_data(symbol)
                if not pos:
                    # Position closed externally ‚Üí clean up orders
                    if current_side is not None:
                        symbol_position_state[symbol] = None
                        symbol_entry_price[symbol] = None
                        symbol_tp_order_id[symbol] = None
                        symbol_sl_order_id[symbol] = None
                    continue

                pnl = float(pos.get("unRealizedProfit", 0))
                if pnl < MAX_ALLOWED_LOSS_USDT:
                    logger.warning(f"[{symbol}] LOSS CUT | PnL {pnl:.2f}")
                    close_position(symbol, "max loss cut")
                    await send_telegram(f"‚ö†Ô∏è LOSS CUT {symbol}  PnL: {pnl:.2f} USDT")
                    continue

                qty = calculate_safe_quantity(symbol)
                if qty < 1e-6: continue

                klines = get_klines(symbol, "5m", 200)
                if not klines or len(klines) < 50: continue

                df = pd.DataFrame(klines, columns=[
                    "ot","open","high","low","close","vol",
                    "ct","qv","n","tbv","tqv","i"
                ])
                df["close"] = df["close"].astype(float)

                hma = hull_moving_average(df["close"], 9)
                rsi_hma = RSIIndicator(hma.dropna(), window=14).rsi()
                sma_rsi = rsi_hma.rolling(14).mean()               # ‚Üê was 5, most probably typo

                if len(sma_rsi.dropna()) < 5: continue

                # Last **completed** bar
                last_rsi   = rsi_hma.iloc[-2]
                prev_rsi   = rsi_hma.iloc[-3]
                last_sma   = sma_rsi.iloc[-2]
                prev_sma   = sma_rsi.iloc[-3]
                prev1_sma  = sma_rsi.iloc[-4]
                last_close = df["close"].iloc[-2]
                last_hma   = hma.iloc[-2]

                mark_price = get_current_price(symbol)
                if mark_price <= 0: continue

                cross_up   = (last_sma > prev_sma) and (prev_sma < prev1_sma)
                cross_down = (last_sma < prev_sma) and (prev_sma > prev1_sma)

                # ‚îÄ‚îÄ‚îÄ New position ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if current_side is None:
                    if cross_up:
                        logger.info(f"[{symbol}] LONG ‚Äì RSI ‚Üë SMA")
                        resp = place_market_order(symbol, "BUY", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "LONG"
                            symbol_entry_price[symbol] = mark_price

                            tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                            tp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                            if "orderId" in tp:
                                symbol_tp_order_id[symbol] = tp["orderId"]

                            sl_price = mark_price * (1 - STOP_LOSS_PCT)
                            sl = place_stop_loss_order(symbol, "LONG", qty, sl_price)
                            if "orderId" in sl:
                                symbol_sl_order_id[symbol] = sl["orderId"]

                            msg = f"üü¢ LONG {symbol} @ {mark_price:.3f}\nTP {tp_price:.3f}  |  SL {sl_price:.3f}"
                            logger.info(msg)
                            await send_telegram(msg)

                    elif cross_down:
                        logger.info(f"[{symbol}] SHORT ‚Äì RSI ‚Üì SMA")
                        resp = place_market_order(symbol, "SELL", qty)
                        if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                            symbol_position_state[symbol] = "SHORT"
                            symbol_entry_price[symbol] = mark_price

                            tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                            tp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                            if "orderId" in tp:
                                symbol_tp_order_id[symbol] = tp["orderId"]

                            sl_price = mark_price * (1 + STOP_LOSS_PCT)
                            sl = place_stop_loss_order(symbol, "SHORT", qty, sl_price)
                            if "orderId" in sl:
                                symbol_sl_order_id[symbol] = sl["orderId"]

                            msg = f"üî¥ SHORT {symbol} @ {mark_price:.3f}\nTP {tp_price:.3f}  |  SL {sl_price:.3f}"
                            logger.info(msg)
                            await send_telegram(msg)

                # ‚îÄ‚îÄ‚îÄ Reversal / exit condition ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif current_side == "LONG" and last_rsi < prev_rsi:
                    logger.info(f"[{symbol}] LONG ‚Üí SHORT (close < HMA)")
                    close_position(symbol, "reversal")
                    await send_telegram(f"üîÑ Reversal {symbol} ‚Üí closing LONG")

                    resp = place_market_order(symbol, "SELL", qty)
                    if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                        symbol_position_state[symbol] = "SHORT"
                        symbol_entry_price[symbol] = mark_price

                        tp_price = mark_price * (1 - TAKE_PROFIT_PCT)
                        tp = place_take_profit_order(symbol, "SHORT", qty, tp_price)
                        if "orderId" in tp:
                            symbol_tp_order_id[symbol] = tp["orderId"]

                        sl_price = mark_price * (1 + STOP_LOSS_PCT)
                        sl = place_stop_loss_order(symbol, "SHORT", qty, sl_price)
                        if "orderId" in sl:
                            symbol_sl_order_id[symbol] = sl["orderId"]

                        msg = f"üî¥ SHORT {symbol} @ {mark_price:.3f} (reversal)\nTP {tp_price:.3f}  |  SL {sl_price:.3f}"
                        await send_telegram(msg)

                elif current_side == "SHORT" and last_rsi > prev_rsi:
                    logger.info(f"[{symbol}] SHORT ‚Üí LONG (close > HMA)")
                    close_position(symbol, "reversal")
                    await send_telegram(f"üîÑ Reversal {symbol} ‚Üí closing SHORT")

                    resp = place_market_order(symbol, "BUY", qty)
                    if resp.get("status") in ("NEW", "FILLED", "PARTIALLY_FILLED"):
                        symbol_position_state[symbol] = "LONG"
                        symbol_entry_price[symbol] = mark_price

                        tp_price = mark_price * (1 + TAKE_PROFIT_PCT)
                        tp = place_take_profit_order(symbol, "LONG", qty, tp_price)
                        if "orderId" in tp:
                            symbol_tp_order_id[symbol] = tp["orderId"]

                        sl_price = mark_price * (1 - STOP_LOSS_PCT)
                        sl = place_stop_loss_order(symbol, "LONG", qty, sl_price)
                        if "orderId" in sl:
                            symbol_sl_order_id[symbol] = sl["orderId"]

                        msg = f"üü¢ LONG {symbol} @ {mark_price:.3f} (reversal)\nTP {tp_price:.3f}  |  SL {sl_price:.3f}"
                        await send_telegram(msg)

                # ‚îÄ‚îÄ‚îÄ Check if TP or SL was filled (position closed) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if current_side is not None and symbol_entry_price.get(symbol) is not None:
                    if pos.get("positionAmt", "0") == "0":
                        entry = symbol_entry_price[symbol]
                        exit_price = float(pos.get("markPrice", mark_price))
                        pnl_pct = (exit_price - entry) / entry * 100 if current_side == "LONG" else (entry - exit_price) / entry * 100

                        if symbol_tp_order_id.get(symbol):
                            await send_telegram(
                                f"‚úÖ TP hit {symbol} {current_side}\n"
                                f"Entry: {entry:.3f} ‚Üí Exit: {exit_price:.3f}\n"
                                f"PnL: +{pnl_pct:.2f}%"
                            )
                        elif symbol_sl_order_id.get(symbol):
                            await send_telegram(
                                f"‚ùå SL hit {symbol} {current_side}\n"
                                f"Entry: {entry:.3f} ‚Üí Exit: {exit_price:.3f}\n"
                                f"PnL: {pnl_pct:.2f}%"
                            )
                        else:
                            await send_telegram(
                                f"Position closed externally {symbol} {current_side}\n"
                                f"Entry: {entry:.3f} ‚Üí Exit: ~{exit_price:.3f}"
                            )

                        # Clean state
                        symbol_position_state[symbol] = None
                        symbol_entry_price[symbol] = None
                        symbol_tp_order_id[symbol] = None
                        symbol_sl_order_id[symbol] = None

            except Exception as e:
                logger.error(f"Error {symbol}: {e}")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Startup
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def on_startup(app: Application) -> None:
    asyncio.create_task(trading_loop(app))
    logger.info("Trading task started")
    await send_telegram("Bot started ‚Äì RSI-on-HMA strategy")

def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("add",   cmd_add))
    app.add_handler(CommandHandler("rem",   cmd_rem))
    app.add_handler(CommandHandler("reset", cmd_rem))
    app.add_handler(CommandHandler("list",  cmd_list))
    app.post_init = on_startup
    print("Bot starting...")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
